{"version":3,"sources":["../node_modules/.pnpm/tsup@8.5.1_postcss@8.5.6_typescript@5.9.3/node_modules/tsup/assets/esm_shims.js","../src/types/config.ts","../src/types/results.ts","../src/types/index.ts","../src/utils/fs.ts","../src/utils/logger.ts","../src/config.ts","../src/cli.ts","../src/core.ts","../src/scanner/env-parser.ts","../src/scanner/code-scanner.ts","../src/utils/glob.ts","../src/frameworks/index.ts","../src/analyzers/missing.ts","../src/analyzers/unused.ts","../src/analyzers/type-mismatch.ts","../src/analyzers/sync-check.ts","../src/analyzers/secret-patterns.ts","../src/reporters/console.ts","../src/reporters/json.ts","../src/reporters/sarif.ts","../src/scanner/git-scanner.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import { z } from 'zod';\n\n/**\n * Supported frameworks for environment variable patterns\n */\nexport type Framework = 'auto' | 'nextjs' | 'vite' | 'cra' | 'node';\n\n/**\n * Variable type for validation\n */\nexport type VariableType = 'string' | 'number' | 'boolean' | 'json' | 'url' | 'email';\n\n/**\n * Rule for a specific environment variable\n */\nexport interface VariableRule {\n  /** Whether this variable is required */\n  required?: boolean;\n  /** Whether this variable contains a secret */\n  secret?: boolean;\n  /** Expected type of the variable */\n  type?: VariableType;\n  /** Regex pattern the value must match */\n  pattern?: RegExp;\n  /** Default value if not provided */\n  default?: string | number | boolean;\n  /** Allowed values (enum) */\n  enum?: string[];\n  /** Description for documentation */\n  description?: string;\n}\n\n/**\n * Main configuration for env-doctor\n */\nexport interface EnvDoctorConfig {\n  /** Environment files to check (default: ['.env']) */\n  envFiles: string[];\n  /** Template file to compare against (e.g., '.env.example') */\n  templateFile?: string;\n  /** Glob patterns for files to scan */\n  include: string[];\n  /** Glob patterns for files to exclude */\n  exclude: string[];\n  /** Framework for env var patterns (default: 'auto') */\n  framework: Framework;\n  /** Variable-specific rules */\n  variables: Record<string, VariableRule>;\n  /** Patterns or rules to ignore */\n  ignore: string[];\n  /** Strict mode - treat warnings as errors */\n  strict?: boolean;\n  /** Custom secret detection patterns */\n  secretPatterns?: RegExp[];\n  /** Root directory to scan (default: process.cwd()) */\n  root?: string;\n}\n\n/**\n * Zod schema for VariableRule\n */\nexport const VariableRuleSchema = z.object({\n  required: z.boolean().optional(),\n  secret: z.boolean().optional(),\n  type: z.enum(['string', 'number', 'boolean', 'json', 'url', 'email']).optional(),\n  pattern: z.instanceof(RegExp).optional(),\n  default: z.union([z.string(), z.number(), z.boolean()]).optional(),\n  enum: z.array(z.string()).optional(),\n  description: z.string().optional(),\n});\n\n/**\n * Zod schema for EnvDoctorConfig\n */\nexport const EnvDoctorConfigSchema = z.object({\n  envFiles: z.array(z.string()).default(['.env']),\n  templateFile: z.string().optional(),\n  include: z.array(z.string()).default(['src/**/*.{ts,js,tsx,jsx}']),\n  exclude: z.array(z.string()).default(['node_modules', 'dist', '**/*.test.*', '**/*.spec.*']),\n  framework: z.enum(['auto', 'nextjs', 'vite', 'cra', 'node']).default('auto'),\n  variables: z.record(z.string(), VariableRuleSchema).default({}),\n  ignore: z.array(z.string()).default([]),\n  strict: z.boolean().optional(),\n  secretPatterns: z.array(z.instanceof(RegExp)).optional(),\n  root: z.string().optional(),\n});\n\n/**\n * Default configuration values\n */\nexport const defaultConfig: EnvDoctorConfig = {\n  envFiles: ['.env'],\n  include: ['src/**/*.{ts,js,tsx,jsx}', 'app/**/*.{ts,js,tsx,jsx}', 'pages/**/*.{ts,js,tsx,jsx}'],\n  exclude: ['node_modules', 'dist', 'build', '.next', '**/*.test.*', '**/*.spec.*', '**/__tests__/**'],\n  framework: 'auto',\n  variables: {},\n  ignore: [],\n  strict: false,\n};\n\n/**\n * CLI options passed from command line\n */\nexport interface CLIOptions {\n  config?: string;\n  env?: string;\n  format?: 'console' | 'json' | 'sarif';\n  ci?: boolean;\n  fix?: boolean;\n  watch?: boolean;\n  verbose?: boolean;\n  depth?: number;\n}\n\n","/**\n * Severity levels for issues\n */\nexport type Severity = 'error' | 'warning' | 'info';\n\n/**\n * Types of issues that can be detected\n */\nexport type IssueType =\n  | 'missing'\n  | 'unused'\n  | 'type-mismatch'\n  | 'sync-drift'\n  | 'secret-exposed'\n  | 'invalid-value'\n  | 'dynamic-access';\n\n/**\n * Location in source code\n */\nexport interface SourceLocation {\n  file: string;\n  line: number;\n  column?: number;\n}\n\n/**\n * A single detected issue\n */\nexport interface Issue {\n  /** Type of the issue */\n  type: IssueType;\n  /** Severity level */\n  severity: Severity;\n  /** Name of the environment variable */\n  variable: string;\n  /** Human-readable message */\n  message: string;\n  /** Location in source code (if applicable) */\n  location?: SourceLocation;\n  /** Suggested fix (if available) */\n  fix?: string;\n  /** Additional context */\n  context?: Record<string, unknown>;\n}\n\n/**\n * Parsed environment variable from .env file\n */\nexport interface EnvVariable {\n  /** Variable name */\n  name: string;\n  /** Variable value (may be empty) */\n  value: string;\n  /** Line number in the file */\n  line: number;\n  /** Source file path */\n  file: string;\n  /** Whether the value appears to be a secret */\n  isSecret?: boolean;\n  /** Inferred type from usage */\n  inferredType?: 'string' | 'number' | 'boolean' | 'json' | 'array';\n  /** Raw line content */\n  raw?: string;\n}\n\n/**\n * Environment variable usage found in code\n */\nexport interface EnvUsage {\n  /** Variable name */\n  name: string;\n  /** File where it's used */\n  file: string;\n  /** Line number */\n  line: number;\n  /** Column number */\n  column: number;\n  /** Access pattern (direct, bracket, destructure) */\n  accessPattern: 'direct' | 'bracket' | 'destructure' | 'dynamic';\n  /** Inferred type from usage context */\n  inferredType?: 'string' | 'number' | 'boolean' | 'json' | 'array';\n  /** Code snippet for context */\n  snippet?: string;\n  /** Whether this is a client-side access (framework specific) */\n  isClientSide?: boolean;\n}\n\n/**\n * Result of scanning git history\n */\nexport interface GitScanResult {\n  /** Commit hash where secret was found */\n  commit: string;\n  /** Author of the commit */\n  author: string;\n  /** Commit date */\n  date: string;\n  /** File path */\n  file: string;\n  /** Line number */\n  line: number;\n  /** Variable name */\n  variable: string;\n  /** Partial value (redacted) */\n  redactedValue: string;\n}\n\n/**\n * Overall analysis result\n */\nexport interface AnalysisResult {\n  /** All detected issues */\n  issues: Issue[];\n  /** Environment variables defined in .env files */\n  definedVariables: EnvVariable[];\n  /** Environment variables used in code */\n  usedVariables: EnvUsage[];\n  /** Template variables from .env.example */\n  templateVariables?: EnvVariable[];\n  /** Detected framework */\n  framework: string;\n  /** Scan statistics */\n  stats: ScanStats;\n}\n\n/**\n * Scan statistics\n */\nexport interface ScanStats {\n  /** Number of files scanned */\n  filesScanned: number;\n  /** Number of env files parsed */\n  envFilesParsed: number;\n  /** Time taken in milliseconds */\n  duration: number;\n  /** Number of errors */\n  errorCount: number;\n  /** Number of warnings */\n  warningCount: number;\n  /** Number of info messages */\n  infoCount: number;\n}\n\n/**\n * SARIF output format for GitHub code scanning\n */\nexport interface SARIFOutput {\n  $schema: string;\n  version: string;\n  runs: SARIFRun[];\n}\n\nexport interface SARIFRun {\n  tool: {\n    driver: {\n      name: string;\n      version: string;\n      informationUri: string;\n      rules: SARIFRule[];\n    };\n  };\n  results: SARIFResult[];\n}\n\nexport interface SARIFRule {\n  id: string;\n  name: string;\n  shortDescription: { text: string };\n  fullDescription: { text: string };\n  defaultConfiguration: { level: 'error' | 'warning' | 'note' };\n  helpUri?: string;\n}\n\nexport interface SARIFResult {\n  ruleId: string;\n  level: 'error' | 'warning' | 'note';\n  message: { text: string };\n  locations: Array<{\n    physicalLocation: {\n      artifactLocation: { uri: string };\n      region: { startLine: number; startColumn?: number };\n    };\n  }>;\n}\n\n","// Re-export all types\nexport * from './config.js';\nexport * from './results.js';\n\n","import { readFile, access, stat } from 'node:fs/promises';\nimport { constants } from 'node:fs';\nimport { resolve, relative, dirname } from 'node:path';\n\n/**\n * Check if a file exists\n */\nexport async function fileExists(path: string): Promise<boolean> {\n  try {\n    await access(path, constants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if a path is a directory\n */\nexport async function isDirectory(path: string): Promise<boolean> {\n  try {\n    const stats = await stat(path);\n    return stats.isDirectory();\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Read a file as text, returning null if it doesn't exist\n */\nexport async function readFileText(path: string): Promise<string | null> {\n  try {\n    return await readFile(path, 'utf-8');\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Read a JSON file, returning null if it doesn't exist or is invalid\n */\nexport async function readJsonFile<T = unknown>(path: string): Promise<T | null> {\n  try {\n    const content = await readFile(path, 'utf-8');\n    return JSON.parse(content) as T;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Resolve a path relative to a root directory\n */\nexport function resolvePath(root: string, ...paths: string[]): string {\n  return resolve(root, ...paths);\n}\n\n/**\n * Get relative path from root\n */\nexport function relativePath(root: string, path: string): string {\n  return relative(root, path);\n}\n\n/**\n * Get directory name from path\n */\nexport function getDirname(path: string): string {\n  return dirname(path);\n}\n\n/**\n * Find a file by searching up the directory tree\n */\nexport async function findUp(filename: string, startDir: string): Promise<string | null> {\n  let currentDir = resolve(startDir);\n  const root = resolve('/');\n\n  while (currentDir !== root) {\n    const filePath = resolve(currentDir, filename);\n    if (await fileExists(filePath)) {\n      return filePath;\n    }\n    currentDir = dirname(currentDir);\n  }\n\n  return null;\n}\n\n","import pc from 'picocolors';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'silent';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n  silent: 4,\n};\n\nclass Logger {\n  private level: LogLevel = 'info';\n  private verbose = false;\n\n  setLevel(level: LogLevel) {\n    this.level = level;\n  }\n\n  setVerbose(verbose: boolean) {\n    this.verbose = verbose;\n    if (verbose) {\n      this.level = 'debug';\n    }\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return LOG_LEVELS[level] >= LOG_LEVELS[this.level];\n  }\n\n  debug(...args: unknown[]) {\n    if (this.shouldLog('debug')) {\n      console.log(pc.gray('[debug]'), ...args);\n    }\n  }\n\n  info(...args: unknown[]) {\n    if (this.shouldLog('info')) {\n      console.log(...args);\n    }\n  }\n\n  success(...args: unknown[]) {\n    if (this.shouldLog('info')) {\n      console.log(pc.green('✓'), ...args);\n    }\n  }\n\n  warn(...args: unknown[]) {\n    if (this.shouldLog('warn')) {\n      console.log(pc.yellow('⚠'), ...args);\n    }\n  }\n\n  error(...args: unknown[]) {\n    if (this.shouldLog('error')) {\n      console.error(pc.red('✗'), ...args);\n    }\n  }\n\n  /** Print without any prefix */\n  log(...args: unknown[]) {\n    if (this.shouldLog('info')) {\n      console.log(...args);\n    }\n  }\n\n  /** Print a blank line */\n  blank() {\n    if (this.shouldLog('info')) {\n      console.log();\n    }\n  }\n\n  /** Print a header */\n  header(text: string) {\n    if (this.shouldLog('info')) {\n      console.log();\n      console.log(pc.bold(pc.cyan(text)));\n      console.log();\n    }\n  }\n\n  /** Print a section divider */\n  divider() {\n    if (this.shouldLog('info')) {\n      console.log(pc.gray('─'.repeat(50)));\n    }\n  }\n}\n\nexport const logger = new Logger();\n\n","import { resolve, dirname } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { EnvDoctorConfigSchema, defaultConfig, type EnvDoctorConfig } from './types/index.js';\nimport { fileExists, readJsonFile, findUp } from './utils/fs.js';\nimport { logger } from './utils/logger.js';\n\nconst CONFIG_FILENAMES = [\n  'env-doctor.config.js',\n  'env-doctor.config.mjs',\n  'env-doctor.config.cjs',\n  '.env-doctor.config.js',\n  '.env-doctor.config.mjs',\n  '.env-doctor.config.cjs',\n  'env-doctor.config.json',\n  '.env-doctorrc',\n  '.env-doctorrc.json',\n];\n\n/**\n * Load configuration from file or use defaults\n */\nexport async function loadConfig(\n  configPath?: string,\n  rootDir: string = process.cwd()\n): Promise<{ config: EnvDoctorConfig; configPath?: string }> {\n  // If explicit path provided, use it\n  if (configPath) {\n    const absolutePath = resolve(rootDir, configPath);\n    if (await fileExists(absolutePath)) {\n      const config = await loadConfigFile(absolutePath);\n      return { config: mergeWithDefaults(config), configPath: absolutePath };\n    }\n    logger.warn(`Config file not found: ${configPath}`);\n    return { config: { ...defaultConfig, root: rootDir } };\n  }\n\n  // Search for config file\n  for (const filename of CONFIG_FILENAMES) {\n    const foundPath = await findUp(filename, rootDir);\n    if (foundPath) {\n      logger.debug(`Found config at ${foundPath}`);\n      const config = await loadConfigFile(foundPath);\n      return {\n        config: mergeWithDefaults(config, dirname(foundPath)),\n        configPath: foundPath,\n      };\n    }\n  }\n\n  // Check package.json for env-doctor key\n  const packageJsonPath = resolve(rootDir, 'package.json');\n  if (await fileExists(packageJsonPath)) {\n    const packageJson = await readJsonFile<{ 'env-doctor'?: Partial<EnvDoctorConfig> }>(\n      packageJsonPath\n    );\n    if (packageJson?.['env-doctor']) {\n      logger.debug('Found config in package.json');\n      return {\n        config: mergeWithDefaults(packageJson['env-doctor'], rootDir),\n        configPath: packageJsonPath,\n      };\n    }\n  }\n\n  // Use defaults\n  logger.debug('No config found, using defaults');\n  return { config: { ...defaultConfig, root: rootDir } };\n}\n\n/**\n * Load a config file\n */\nasync function loadConfigFile(filePath: string): Promise<Partial<EnvDoctorConfig>> {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n\n  try {\n    if (ext === 'json' || filePath.endsWith('rc')) {\n      const content = await readJsonFile<Partial<EnvDoctorConfig>>(filePath);\n      return content || {};\n    }\n\n    // For JS/MJS files, use dynamic import\n    const fileUrl = pathToFileURL(filePath).href;\n    const module = await import(fileUrl);\n    return module.default || module;\n  } catch (err) {\n    logger.warn(`Failed to load config from ${filePath}: ${err instanceof Error ? err.message : 'Unknown error'}`);\n    return {};\n  }\n}\n\n/**\n * Merge user config with defaults\n */\nfunction mergeWithDefaults(\n  userConfig: Partial<EnvDoctorConfig>,\n  rootDir?: string\n): EnvDoctorConfig {\n  const merged = {\n    ...defaultConfig,\n    ...userConfig,\n    root: userConfig.root || rootDir || process.cwd(),\n    variables: {\n      ...defaultConfig.variables,\n      ...userConfig.variables,\n    },\n  };\n\n  // Validate with Zod\n  const result = EnvDoctorConfigSchema.safeParse(merged);\n  if (!result.success) {\n    logger.warn('Config validation warnings:');\n    for (const issue of result.error.issues) {\n      logger.warn(`  ${issue.path.join('.')}: ${issue.message}`);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Create a config file template\n */\nexport function generateConfigTemplate(): string {\n  return `// env-doctor.config.js\n// See https://github.com/yourusername/env-doctor for documentation\n\n/** @type {import('env-doctor').EnvDoctorConfig} */\nmodule.exports = {\n  // Which env files to check\n  envFiles: ['.env', '.env.local'],\n\n  // Compare against this template\n  templateFile: '.env.example',\n\n  // Where to scan for usage\n  include: ['src/**/*.{ts,js,tsx,jsx}', 'app/**/*.{ts,js,tsx,jsx}'],\n  exclude: ['node_modules', 'dist', '**/*.test.*'],\n\n  // Framework detection (auto-detected by default)\n  framework: 'auto', // 'nextjs' | 'vite' | 'cra' | 'node' | 'auto'\n\n  // Variable-specific rules\n  variables: {\n    // DATABASE_URL: {\n    //   required: true,\n    //   secret: true,\n    //   pattern: /^postgres:\\\\/\\\\//\n    // },\n    // PORT: {\n    //   type: 'number',\n    //   default: 3000\n    // },\n    // NODE_ENV: {\n    //   enum: ['development', 'production', 'test']\n    // }\n  },\n\n  // Ignore specific issues\n  ignore: [\n    // 'LEGACY_*',           // Ignore variables matching pattern\n    // 'unused:DEBUG',       // Ignore specific rule for specific var\n  ],\n\n  // Strict mode - treat warnings as errors\n  strict: false,\n};\n`;\n}\n\n/**\n * Get environment-specific config overrides\n */\nexport function getEnvSpecificConfig(\n  baseConfig: EnvDoctorConfig,\n  env: string\n): EnvDoctorConfig {\n  // Map environment names to env file patterns\n  const envFileMap: Record<string, string[]> = {\n    development: ['.env', '.env.local', '.env.development', '.env.development.local'],\n    production: ['.env', '.env.production', '.env.production.local'],\n    test: ['.env', '.env.test', '.env.test.local'],\n    staging: ['.env', '.env.staging', '.env.staging.local'],\n  };\n\n  const envFiles = envFileMap[env] || [`.env.${env}`];\n\n  return {\n    ...baseConfig,\n    envFiles,\n  };\n}\n\n/**\n * Validate that required config values are present\n */\nexport function validateConfig(config: EnvDoctorConfig): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (!config.envFiles || config.envFiles.length === 0) {\n    errors.push('At least one env file must be specified');\n  }\n\n  if (!config.include || config.include.length === 0) {\n    errors.push('At least one include pattern must be specified');\n  }\n\n  // Validate variable rules\n  for (const [name, rule] of Object.entries(config.variables)) {\n    if (rule.pattern && !(rule.pattern instanceof RegExp)) {\n      errors.push(`Variable \"${name}\": pattern must be a RegExp`);\n    }\n\n    if (rule.enum && !Array.isArray(rule.enum)) {\n      errors.push(`Variable \"${name}\": enum must be an array`);\n    }\n\n    if (rule.type && !['string', 'number', 'boolean', 'json', 'url', 'email'].includes(rule.type)) {\n      errors.push(`Variable \"${name}\": invalid type \"${rule.type}\"`);\n    }\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n\n","#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport pc from 'picocolors';\nimport { resolve } from 'node:path';\nimport { writeFile } from 'node:fs/promises';\nimport { loadConfig, generateConfigTemplate, getEnvSpecificConfig } from './config.js';\nimport { analyze } from './core.js';\nimport { reportToConsole, reportForCI, createSpinner } from './reporters/console.js';\nimport { reportToJSON } from './reporters/json.js';\nimport { reportToSARIF } from './reporters/sarif.js';\nimport { scanGitHistory } from './scanner/git-scanner.js';\nimport { generateTemplate } from './analyzers/sync-check.js';\nimport { getSecurityRecommendations } from './analyzers/secret-patterns.js';\nimport { logger } from './utils/logger.js';\nimport { fileExists } from './utils/fs.js';\nimport type { AnalysisResult } from './types/index.js';\n\nconst VERSION = '1.0.0';\n\nconst program = new Command();\n\nprogram\n  .name('env-doctor')\n  .description('Analyze and validate environment variables in your codebase')\n  .version(VERSION);\n\n// Default command - scan\nprogram\n  .argument('[directory]', 'Directory to scan', process.cwd())\n  .option('-c, --config <path>', 'Path to config file')\n  .option('-e, --env <environment>', 'Target environment (development, production, test)')\n  .option('-f, --format <format>', 'Output format (console, json, sarif)', 'console')\n  .option('--ci', 'CI mode - exit with code 1 on errors')\n  .option('-v, --verbose', 'Verbose output')\n  .option('--strict', 'Treat warnings as errors')\n  .action(async (directory: string, options) => {\n    await runScan(directory, options);\n  });\n\n// Init command - create config and .env.example\nprogram\n  .command('init')\n  .description('Initialize env-doctor in your project')\n  .option('--config-only', 'Only create config file')\n  .option('--example-only', 'Only create .env.example')\n  .option('-f, --force', 'Overwrite existing files')\n  .action(async (options) => {\n    await runInit(options);\n  });\n\n// Fix command - interactive fixing\nprogram\n  .command('fix')\n  .description('Interactively fix environment issues')\n  .option('-c, --config <path>', 'Path to config file')\n  .option('--dry-run', 'Show what would be fixed without making changes')\n  .action(async (options) => {\n    await runFix(options);\n  });\n\n// Scan history command\nprogram\n  .command('scan-history')\n  .description('Scan git history for leaked secrets')\n  .option('-d, --depth <number>', 'Number of commits to scan', '100')\n  .option('-f, --format <format>', 'Output format (console, json)', 'console')\n  .action(async (options) => {\n    await runScanHistory(options);\n  });\n\n// Watch command\nprogram\n  .command('watch')\n  .description('Watch for changes and re-analyze')\n  .option('-c, --config <path>', 'Path to config file')\n  .action(async (options) => {\n    await runWatch(options);\n  });\n\n// Parse and execute\nprogram.parse();\n\n/**\n * Main scan command\n */\nasync function runScan(\n  directory: string,\n  options: {\n    config?: string;\n    env?: string;\n    format: string;\n    ci?: boolean;\n    verbose?: boolean;\n    strict?: boolean;\n  }\n): Promise<void> {\n  const rootDir = resolve(directory);\n\n  if (options.verbose) {\n    logger.setVerbose(true);\n  }\n\n  try {\n    // Load config\n    let { config } = await loadConfig(options.config, rootDir);\n\n    // Apply environment-specific overrides\n    if (options.env) {\n      config = getEnvSpecificConfig(config, options.env);\n    }\n\n    // Apply strict mode\n    if (options.strict) {\n      config.strict = true;\n    }\n\n    // Run analysis\n    const spinner = options.format === 'console' && !options.ci ? createSpinner('Scanning project...') : null;\n    spinner?.start();\n\n    const result = await analyze({ config, verbose: options.verbose });\n\n    spinner?.stop(result.stats.errorCount === 0);\n\n    // Output results\n    switch (options.format) {\n      case 'json':\n        console.log(reportToJSON(result));\n        break;\n      case 'sarif':\n        console.log(reportToSARIF(result));\n        break;\n      default:\n        if (options.ci) {\n          reportForCI(result);\n        } else {\n          reportToConsole(result, { verbose: options.verbose });\n        }\n    }\n\n    // Exit with appropriate code\n    const hasErrors = config.strict\n      ? result.stats.errorCount > 0 || result.stats.warningCount > 0\n      : result.stats.errorCount > 0;\n\n    if (options.ci && hasErrors) {\n      process.exit(1);\n    }\n  } catch (err) {\n    logger.error('Analysis failed:', err instanceof Error ? err.message : 'Unknown error');\n    if (options.verbose && err instanceof Error) {\n      console.error(err.stack);\n    }\n    process.exit(1);\n  }\n}\n\n/**\n * Init command\n */\nasync function runInit(options: {\n  configOnly?: boolean;\n  exampleOnly?: boolean;\n  force?: boolean;\n}): Promise<void> {\n  const rootDir = process.cwd();\n\n  console.log();\n  console.log(pc.bold(pc.cyan('env-doctor')) + ' init');\n  console.log();\n\n  // Create config file\n  if (!options.exampleOnly) {\n    const configPath = resolve(rootDir, 'env-doctor.config.js');\n\n    if ((await fileExists(configPath)) && !options.force) {\n      logger.warn('Config file already exists. Use --force to overwrite.');\n    } else {\n      await writeFile(configPath, generateConfigTemplate());\n      logger.success(`Created ${pc.cyan('env-doctor.config.js')}`);\n    }\n  }\n\n  // Create .env.example\n  if (!options.configOnly) {\n    const examplePath = resolve(rootDir, '.env.example');\n\n    if ((await fileExists(examplePath)) && !options.force) {\n      logger.warn('.env.example already exists. Use --force to overwrite.');\n    } else {\n      // Scan the project first to find all used variables\n      const { config } = await loadConfig(undefined, rootDir);\n      const result = await analyze({ config });\n\n      // Generate template from used variables\n      const allVars = [\n        ...result.definedVariables,\n        ...result.usedVariables\n          .filter((u) => u.name !== '<dynamic>')\n          .filter((u) => !result.definedVariables.find((d) => d.name === u.name))\n          .map((u) => ({\n            name: u.name,\n            value: '',\n            line: 0,\n            file: '.env.example',\n          })),\n      ];\n\n      // Remove duplicates\n      const uniqueVars = Array.from(new Map(allVars.map((v) => [v.name, v])).values());\n\n      const templateContent = generateTemplate(uniqueVars, {\n        includeComments: true,\n        groupByPrefix: true,\n        maskSecrets: true,\n      });\n\n      await writeFile(examplePath, templateContent);\n      logger.success(`Created ${pc.cyan('.env.example')} with ${uniqueVars.length} variables`);\n    }\n  }\n\n  console.log();\n  console.log(pc.gray('Next steps:'));\n  console.log(pc.gray('  1. Edit env-doctor.config.js to customize rules'));\n  console.log(pc.gray('  2. Run `env-doctor` to scan your project'));\n  console.log();\n}\n\n/**\n * Fix command - interactive mode\n */\nasync function runFix(options: {\n  config?: string;\n  dryRun?: boolean;\n}): Promise<void> {\n  const rootDir = process.cwd();\n\n  console.log();\n  console.log(pc.bold(pc.cyan('env-doctor')) + ' fix');\n  console.log();\n\n  try {\n    // Load config and analyze\n    const { config } = await loadConfig(options.config, rootDir);\n    const result = await analyze({ config });\n\n    if (result.issues.length === 0) {\n      logger.success('No issues to fix!');\n      return;\n    }\n\n    // Import inquirer dynamically\n    const { select, confirm, input } = await import('@inquirer/prompts');\n\n    // Group fixable issues\n    const missingIssues = result.issues.filter((i) => i.type === 'missing');\n    const syncIssues = result.issues.filter((i) => i.type === 'sync-drift');\n\n    if (missingIssues.length > 0) {\n      console.log(pc.yellow(`\\nFound ${missingIssues.length} missing variable(s)`));\n\n      for (const issue of missingIssues) {\n        const action = await select({\n          message: `${issue.variable} - ${issue.message}`,\n          choices: [\n            { name: 'Add to .env', value: 'add' },\n            { name: 'Add to ignore list', value: 'ignore' },\n            { name: 'Skip', value: 'skip' },\n          ],\n        });\n\n        if (action === 'add') {\n          const value = await input({\n            message: `Enter value for ${issue.variable}:`,\n            default: '',\n          });\n\n          if (!options.dryRun) {\n            // Append to .env file\n            const envPath = resolve(rootDir, '.env');\n            const content = `\\n${issue.variable}=${value}\\n`;\n            await writeFile(envPath, content, { flag: 'a' });\n            logger.success(`Added ${issue.variable} to .env`);\n          } else {\n            logger.info(`[dry-run] Would add ${issue.variable}=${value} to .env`);\n          }\n        } else if (action === 'ignore') {\n          logger.info(`Add '${issue.variable}' to ignore list in config`);\n        }\n      }\n    }\n\n    if (syncIssues.length > 0) {\n      console.log(pc.yellow(`\\nFound ${syncIssues.length} sync issue(s)`));\n\n      const shouldSync = await confirm({\n        message: 'Update .env.example to match .env?',\n        default: true,\n      });\n\n      if (shouldSync && !options.dryRun) {\n        const examplePath = resolve(rootDir, '.env.example');\n        const templateContent = generateTemplate(result.definedVariables, {\n          includeComments: true,\n          groupByPrefix: true,\n          maskSecrets: true,\n        });\n\n        await writeFile(examplePath, templateContent);\n        logger.success('Updated .env.example');\n      }\n    }\n\n    // Show security recommendations if applicable\n    const recommendations = getSecurityRecommendations(result.issues);\n    if (recommendations.length > 0) {\n      console.log();\n      console.log(pc.bold('Security Recommendations:'));\n      for (const rec of recommendations) {\n        console.log(pc.gray(`  • ${rec}`));\n      }\n    }\n\n    console.log();\n  } catch (err) {\n    if ((err as Error).name === 'ExitPromptError') {\n      // User cancelled\n      console.log();\n      return;\n    }\n    throw err;\n  }\n}\n\n/**\n * Scan git history command\n */\nasync function runScanHistory(options: {\n  depth: string;\n  format: string;\n}): Promise<void> {\n  const rootDir = process.cwd();\n  const depth = parseInt(options.depth, 10);\n\n  console.log();\n  console.log(pc.bold(pc.cyan('env-doctor')) + ' scan-history');\n  console.log();\n\n  const spinner = createSpinner(`Scanning last ${depth} commits...`);\n  spinner.start();\n\n  const { results, error } = await scanGitHistory({\n    rootDir,\n    depth,\n  });\n\n  spinner.stop(!error);\n\n  if (error) {\n    logger.error(error);\n    process.exit(1);\n  }\n\n  if (results.length === 0) {\n    logger.success('No leaked secrets found in git history');\n    return;\n  }\n\n  if (options.format === 'json') {\n    console.log(JSON.stringify({ results }, null, 2));\n    return;\n  }\n\n  console.log(pc.red(`\\n⚠ Found ${results.length} potential secret(s) in git history:\\n`));\n\n  for (const result of results) {\n    console.log(pc.bold(`  ${result.variable}`));\n    console.log(pc.gray(`    Commit: ${result.commit.slice(0, 8)}`));\n    console.log(pc.gray(`    File: ${result.file}:${result.line}`));\n    console.log(pc.gray(`    Author: ${result.author}`));\n    console.log(pc.gray(`    Date: ${result.date}`));\n    console.log(pc.gray(`    Value: ${result.redactedValue}`));\n    console.log();\n  }\n\n  console.log(pc.yellow('Recommendation: Consider rotating these credentials and using git-filter-branch or BFG to remove them from history.'));\n  console.log();\n\n  process.exit(1);\n}\n\n/**\n * Watch command\n */\nasync function runWatch(options: { config?: string }): Promise<void> {\n  const rootDir = process.cwd();\n\n  console.log();\n  console.log(pc.bold(pc.cyan('env-doctor')) + ' watch');\n  console.log(pc.gray('Watching for changes... Press Ctrl+C to stop.'));\n  console.log();\n\n  const { config } = await loadConfig(options.config, rootDir);\n\n  let analysisResult: AnalysisResult | null = null;\n  let debounceTimer: NodeJS.Timeout | null = null;\n\n  const runAnalysis = async () => {\n    try {\n      const result = await analyze({ config });\n\n      // Only report if something changed\n      if (\n        !analysisResult ||\n        result.issues.length !== analysisResult.issues.length ||\n        result.stats.errorCount !== analysisResult.stats.errorCount\n      ) {\n        console.clear();\n        console.log(pc.bold(pc.cyan('env-doctor')) + ' watch');\n        console.log(pc.gray(`Last updated: ${new Date().toLocaleTimeString()}`));\n        console.log();\n        reportToConsole(result, { verbose: false });\n        analysisResult = result;\n      }\n    } catch (err) {\n      logger.error('Analysis error:', err instanceof Error ? err.message : 'Unknown error');\n    }\n  };\n\n  // Initial run\n  await runAnalysis();\n\n  // Watch for file changes using fs.watch\n  const { watch } = await import('node:fs');\n  const watchedDirs = new Set<string>();\n\n  // Watch .env files\n  for (const envFile of config.envFiles) {\n    const envPath = resolve(rootDir, envFile);\n    try {\n      watch(envPath, () => {\n        if (debounceTimer) clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(runAnalysis, 300);\n      });\n      watchedDirs.add(envPath);\n    } catch {\n      // File might not exist\n    }\n  }\n\n  // Watch src directory\n  const srcDir = resolve(rootDir, 'src');\n  try {\n    watch(srcDir, { recursive: true }, (_event, filename) => {\n      if (filename && /\\.(ts|js|tsx|jsx)$/.test(filename)) {\n        if (debounceTimer) clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(runAnalysis, 300);\n      }\n    });\n    watchedDirs.add(srcDir);\n  } catch {\n    // Directory might not exist\n  }\n\n  // Keep process alive\n  process.on('SIGINT', () => {\n    console.log();\n    console.log(pc.gray('Stopped watching.'));\n    process.exit(0);\n  });\n\n  // Prevent exit\n  await new Promise(() => {});\n}\n\n","import type { EnvDoctorConfig, AnalysisResult, Issue, EnvVariable, EnvUsage } from './types/index.js';\nimport { parseEnvFile, parseEnvFiles } from './scanner/env-parser.js';\nimport { scanCode } from './scanner/code-scanner.js';\nimport { detectFramework } from './frameworks/index.js';\nimport { analyzeMissing } from './analyzers/missing.js';\nimport { analyzeUnused } from './analyzers/unused.js';\nimport { analyzeTypeMismatch } from './analyzers/type-mismatch.js';\nimport { analyzeSyncDrift } from './analyzers/sync-check.js';\nimport { analyzeSecrets } from './analyzers/secret-patterns.js';\nimport { logger } from './utils/logger.js';\n\nexport interface AnalyzeOptions {\n  config: EnvDoctorConfig;\n  verbose?: boolean;\n}\n\n/**\n * Main analysis function - orchestrates all scanners and analyzers\n */\nexport async function analyze(options: AnalyzeOptions): Promise<AnalysisResult> {\n  const { config, verbose = false } = options;\n  const startTime = Date.now();\n  const rootDir = config.root || process.cwd();\n\n  if (verbose) {\n    logger.setVerbose(true);\n  }\n\n  logger.debug('Starting analysis...');\n  logger.debug(`Root directory: ${rootDir}`);\n\n  // Detect framework if auto\n  let framework = config.framework;\n  if (framework === 'auto') {\n    framework = await detectFramework(rootDir);\n    logger.debug(`Auto-detected framework: ${framework}`);\n  }\n\n  // Parse env files\n  logger.debug(`Parsing env files: ${config.envFiles.join(', ')}`);\n  const envResult = await parseEnvFiles(config.envFiles, rootDir);\n  const definedVariables: EnvVariable[] = envResult.variables;\n\n  if (envResult.errors.length > 0) {\n    logger.debug(`Env parsing errors: ${envResult.errors.length}`);\n  }\n\n  // Parse template file if specified\n  let templateVariables: EnvVariable[] | undefined;\n  if (config.templateFile) {\n    logger.debug(`Parsing template file: ${config.templateFile}`);\n    const templateResult = await parseEnvFile(config.templateFile, rootDir);\n    if (templateResult.variables.length > 0) {\n      templateVariables = templateResult.variables;\n    }\n  }\n\n  // Scan code for usage\n  logger.debug('Scanning code for env usage...');\n  const codeResult = await scanCode({\n    rootDir,\n    include: config.include,\n    exclude: config.exclude,\n    framework,\n  });\n  const usedVariables: EnvUsage[] = codeResult.usages;\n\n  logger.debug(`Found ${usedVariables.length} env usages in ${codeResult.filesScanned} files`);\n\n  // Run all analyzers\n  const issues: Issue[] = [];\n\n  // 1. Missing variables\n  logger.debug('Analyzing missing variables...');\n  const missingIssues = analyzeMissing({\n    definedVariables,\n    usedVariables,\n    config,\n  });\n  issues.push(...missingIssues);\n\n  // 2. Unused variables\n  logger.debug('Analyzing unused variables...');\n  const unusedIssues = analyzeUnused({\n    definedVariables,\n    usedVariables,\n    config,\n    framework,\n  });\n  issues.push(...unusedIssues);\n\n  // 3. Type mismatches\n  logger.debug('Analyzing type mismatches...');\n  const typeMismatchIssues = analyzeTypeMismatch({\n    definedVariables,\n    usedVariables,\n    config,\n  });\n  issues.push(...typeMismatchIssues);\n\n  // 4. Sync check (if template file provided)\n  if (templateVariables) {\n    logger.debug('Analyzing sync drift...');\n    const syncResult = analyzeSyncDrift({\n      envVariables: definedVariables,\n      templateVariables,\n      templateFile: config.templateFile!,\n    });\n    issues.push(...syncResult.issues);\n  }\n\n  // 5. Secret patterns\n  logger.debug('Analyzing secrets...');\n  const secretIssues = analyzeSecrets({\n    variables: definedVariables,\n    customPatterns: config.secretPatterns,\n    ignorePatterns: config.ignore,\n  });\n  issues.push(...secretIssues);\n\n  // Calculate stats\n  const duration = Date.now() - startTime;\n  const errorCount = issues.filter((i) => i.severity === 'error').length;\n  const warningCount = issues.filter((i) => i.severity === 'warning').length;\n  const infoCount = issues.filter((i) => i.severity === 'info').length;\n\n  logger.debug(`Analysis complete in ${duration}ms`);\n  logger.debug(`Found ${issues.length} issues (${errorCount} errors, ${warningCount} warnings, ${infoCount} info)`);\n\n  return {\n    issues,\n    definedVariables,\n    usedVariables,\n    templateVariables,\n    framework,\n    stats: {\n      filesScanned: codeResult.filesScanned,\n      envFilesParsed: config.envFiles.length,\n      duration,\n      errorCount,\n      warningCount,\n      infoCount,\n    },\n  };\n}\n\n/**\n * Quick analysis with minimal config\n */\nexport async function quickAnalyze(rootDir: string = process.cwd()): Promise<AnalysisResult> {\n  const { loadConfig } = await import('./config.js');\n  const { config } = await loadConfig(undefined, rootDir);\n  return analyze({ config });\n}\n\n","import { readFile } from 'node:fs/promises';\nimport { resolve } from 'node:path';\nimport type { EnvVariable } from '../types/index.js';\nimport { fileExists } from '../utils/fs.js';\nimport { logger } from '../utils/logger.js';\n\n/**\n * Common patterns that indicate a value is a secret\n */\nconst SECRET_PATTERNS = [\n  /password/i,\n  /secret/i,\n  /api[_-]?key/i,\n  /auth[_-]?token/i,\n  /access[_-]?token/i,\n  /private[_-]?key/i,\n  /jwt/i,\n  /bearer/i,\n  /credential/i,\n  /^AWS_/i,\n  /^STRIPE_/i,\n  /^GITHUB_TOKEN/i,\n  /^DATABASE_URL$/i,\n  /^REDIS_URL$/i,\n  /^MONGODB_URI$/i,\n];\n\n/**\n * Patterns that indicate the value looks like it contains credentials\n */\nconst CREDENTIAL_VALUE_PATTERNS = [\n  /^sk[-_]/i, // Stripe secret key\n  /^pk[-_]/i, // Stripe publishable key\n  /^ghp_/, // GitHub personal access token\n  /^gho_/, // GitHub OAuth token\n  /^github_pat_/, // GitHub PAT\n  /^AKIA[A-Z0-9]{16}/, // AWS access key\n  /^eyJ[A-Za-z0-9-_]+\\.eyJ/, // JWT token\n  /-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----/, // Private key\n];\n\nexport interface ParseResult {\n  variables: EnvVariable[];\n  errors: Array<{ line: number; message: string }>;\n}\n\n/**\n * Parse a .env file and extract all variables\n */\nexport async function parseEnvFile(\n  filePath: string,\n  rootDir: string = process.cwd()\n): Promise<ParseResult> {\n  const absolutePath = resolve(rootDir, filePath);\n  const variables: EnvVariable[] = [];\n  const errors: Array<{ line: number; message: string }> = [];\n\n  if (!(await fileExists(absolutePath))) {\n    logger.debug(`Env file not found: ${absolutePath}`);\n    return { variables, errors: [{ line: 0, message: `File not found: ${filePath}` }] };\n  }\n\n  let content: string;\n  try {\n    content = await readFile(absolutePath, 'utf-8');\n  } catch (err) {\n    const message = err instanceof Error ? err.message : 'Unknown error';\n    return { variables, errors: [{ line: 0, message: `Failed to read file: ${message}` }] };\n  }\n\n  const lines = content.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    const lineNumber = i + 1;\n    const rawLine = lines[i];\n    const line = rawLine.trim();\n\n    // Skip empty lines and comments\n    if (!line || line.startsWith('#')) {\n      continue;\n    }\n\n    // Parse the line\n    const parsed = parseLine(line, lineNumber);\n\n    if (parsed.error) {\n      errors.push({ line: lineNumber, message: parsed.error });\n      continue;\n    }\n\n    if (parsed.variable) {\n      variables.push({\n        ...parsed.variable,\n        file: filePath,\n        raw: rawLine,\n        isSecret: isSecretVariable(parsed.variable.name, parsed.variable.value),\n      });\n    }\n  }\n\n  return { variables, errors };\n}\n\ninterface LineParseResult {\n  variable?: Omit<EnvVariable, 'file' | 'raw' | 'isSecret'>;\n  error?: string;\n}\n\n/**\n * Parse a single line from an env file\n */\nfunction parseLine(line: string, lineNumber: number): LineParseResult {\n  // Handle export prefix\n  let processedLine = line;\n  if (processedLine.startsWith('export ')) {\n    processedLine = processedLine.slice(7);\n  }\n\n  // Find the first = sign\n  const equalIndex = processedLine.indexOf('=');\n\n  if (equalIndex === -1) {\n    // Line without = might be valid in some formats, skip with warning\n    return { error: `Invalid format: missing '=' sign` };\n  }\n\n  const name = processedLine.slice(0, equalIndex).trim();\n  let value = processedLine.slice(equalIndex + 1);\n\n  // Validate variable name\n  if (!isValidVariableName(name)) {\n    return { error: `Invalid variable name: \"${name}\"` };\n  }\n\n  // Parse the value (handle quotes, multiline, etc.)\n  value = parseValue(value);\n\n  return {\n    variable: {\n      name,\n      value,\n      line: lineNumber,\n    },\n  };\n}\n\n/**\n * Parse a value, handling quotes and escape sequences\n */\nfunction parseValue(value: string): string {\n  value = value.trim();\n\n  // Handle quoted values\n  if (\n    (value.startsWith('\"') && value.endsWith('\"')) ||\n    (value.startsWith(\"'\") && value.endsWith(\"'\"))\n  ) {\n    const quote = value[0];\n    value = value.slice(1, -1);\n\n    // Handle escape sequences for double quotes\n    if (quote === '\"') {\n      value = value\n        .replace(/\\\\n/g, '\\n')\n        .replace(/\\\\r/g, '\\r')\n        .replace(/\\\\t/g, '\\t')\n        .replace(/\\\\\"/g, '\"')\n        .replace(/\\\\\\\\/g, '\\\\');\n    }\n  } else {\n    // Remove inline comments for unquoted values\n    const commentIndex = value.indexOf(' #');\n    if (commentIndex !== -1) {\n      value = value.slice(0, commentIndex).trim();\n    }\n  }\n\n  return value;\n}\n\n/**\n * Check if a variable name is valid\n */\nfunction isValidVariableName(name: string): boolean {\n  // Must start with letter or underscore, followed by letters, numbers, or underscores\n  return /^[A-Za-z_][A-Za-z0-9_]*$/.test(name);\n}\n\n/**\n * Check if a variable is likely a secret based on name and value\n */\nfunction isSecretVariable(name: string, value: string): boolean {\n  // Check name patterns\n  for (const pattern of SECRET_PATTERNS) {\n    if (pattern.test(name)) {\n      return true;\n    }\n  }\n\n  // Check value patterns (only if value is non-empty)\n  if (value) {\n    for (const pattern of CREDENTIAL_VALUE_PATTERNS) {\n      if (pattern.test(value)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Parse multiple env files and merge results\n */\nexport async function parseEnvFiles(\n  filePaths: string[],\n  rootDir: string = process.cwd()\n): Promise<ParseResult> {\n  const allVariables: EnvVariable[] = [];\n  const allErrors: Array<{ line: number; message: string }> = [];\n  const seenVariables = new Map<string, EnvVariable>();\n\n  for (const filePath of filePaths) {\n    const result = await parseEnvFile(filePath, rootDir);\n\n    // Later files override earlier ones (like dotenv behavior)\n    for (const variable of result.variables) {\n      seenVariables.set(variable.name, variable);\n    }\n\n    allErrors.push(...result.errors);\n  }\n\n  // Convert map back to array\n  allVariables.push(...seenVariables.values());\n\n  return { variables: allVariables, errors: allErrors };\n}\n\n/**\n * Infer the type of a value\n */\nexport function inferValueType(\n  value: string\n): 'string' | 'number' | 'boolean' | 'json' | 'array' | undefined {\n  if (!value) return undefined;\n\n  // Boolean\n  if (value === 'true' || value === 'false') {\n    return 'boolean';\n  }\n\n  // Number\n  if (/^-?\\d+(\\.\\d+)?$/.test(value)) {\n    return 'number';\n  }\n\n  // JSON object or array\n  if ((value.startsWith('{') && value.endsWith('}')) || (value.startsWith('[') && value.endsWith(']'))) {\n    try {\n      JSON.parse(value);\n      return 'json';\n    } catch {\n      // Not valid JSON, continue\n    }\n  }\n\n  // Comma-separated array\n  if (value.includes(',') && !value.includes(' ')) {\n    return 'array';\n  }\n\n  return 'string';\n}\n\n/**\n * Get all secret patterns (built-in + custom)\n */\nexport function getSecretPatterns(customPatterns?: RegExp[]): RegExp[] {\n  if (customPatterns) {\n    return [...SECRET_PATTERNS, ...customPatterns];\n  }\n  return SECRET_PATTERNS;\n}\n\n","import { parse } from '@typescript-eslint/typescript-estree';\nimport type { TSESTree } from '@typescript-eslint/typescript-estree';\nimport { readFile } from 'node:fs/promises';\nimport { relative } from 'node:path';\nimport type { EnvUsage, Framework } from '../types/index.js';\nimport { findFiles } from '../utils/glob.js';\nimport { logger } from '../utils/logger.js';\n\nexport interface CodeScanOptions {\n  /** Root directory */\n  rootDir: string;\n  /** Include patterns */\n  include: string[];\n  /** Exclude patterns */\n  exclude: string[];\n  /** Detected framework */\n  framework: Framework | string;\n}\n\nexport interface CodeScanResult {\n  usages: EnvUsage[];\n  errors: Array<{ file: string; message: string }>;\n  filesScanned: number;\n}\n\n/**\n * Framework-specific prefixes for client-side env vars\n */\nconst CLIENT_PREFIXES: Record<string, string[]> = {\n  nextjs: ['NEXT_PUBLIC_'],\n  vite: ['VITE_'],\n  cra: ['REACT_APP_'],\n  node: [],\n};\n\n/**\n * Scan source files for process.env usage\n */\nexport async function scanCode(options: CodeScanOptions): Promise<CodeScanResult> {\n  const { rootDir, include, exclude, framework } = options;\n\n  const usages: EnvUsage[] = [];\n  const errors: Array<{ file: string; message: string }> = [];\n\n  // Find all source files\n  const files = await findFiles({\n    cwd: rootDir,\n    include,\n    exclude,\n  });\n\n  logger.debug(`Found ${files.length} files to scan`);\n\n  for (const file of files) {\n    try {\n      const content = await readFile(file, 'utf-8');\n      const fileUsages = scanFileContent(content, file, rootDir, framework);\n      usages.push(...fileUsages);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Unknown error';\n      errors.push({ file: relative(rootDir, file), message });\n      logger.debug(`Error scanning ${file}: ${message}`);\n    }\n  }\n\n  return {\n    usages,\n    errors,\n    filesScanned: files.length,\n  };\n}\n\n/**\n * Scan a single file's content for env usage\n */\nexport function scanFileContent(\n  content: string,\n  filePath: string,\n  rootDir: string,\n  framework: Framework | string\n): EnvUsage[] {\n  const usages: EnvUsage[] = [];\n  const relativePath = relative(rootDir, filePath);\n\n  // Determine if this is likely a client-side file\n  const isClientFile = isClientSideFile(filePath);\n\n  // Get client prefixes for this framework\n  const clientPrefixes = CLIENT_PREFIXES[framework] || [];\n\n  try {\n    const ast = parse(content, {\n      jsx: true,\n      loc: true,\n      range: true,\n      comment: false,\n      errorOnUnknownASTType: false,\n    });\n\n    // Walk the AST\n    walkAST(ast, (node) => {\n      const usage = extractEnvUsage(node, relativePath, isClientFile, clientPrefixes, content);\n      if (usage) {\n        usages.push(usage);\n      }\n    });\n  } catch {\n    // If AST parsing fails, fall back to regex-based scanning\n    logger.debug(`AST parsing failed for ${filePath}, using regex fallback`);\n    usages.push(...scanWithRegex(content, relativePath, isClientFile, clientPrefixes));\n  }\n\n  return usages;\n}\n\n/**\n * Extract env usage from an AST node\n */\nfunction extractEnvUsage(\n  node: TSESTree.Node,\n  file: string,\n  isClientFile: boolean,\n  clientPrefixes: string[],\n  _content: string\n): EnvUsage | null {\n  // Pattern 1: process.env.VAR_NAME\n  if (\n    node.type === 'MemberExpression' &&\n    isProcessEnv(node.object) &&\n    node.property.type === 'Identifier'\n  ) {\n    const name = node.property.name;\n    return {\n      name,\n      file,\n      line: node.loc?.start.line ?? 0,\n      column: node.loc?.start.column ?? 0,\n      accessPattern: 'direct',\n      isClientSide: isClientFile || isClientVariable(name, clientPrefixes),\n      inferredType: inferTypeFromContext(node),\n    };\n  }\n\n  // Pattern 2: process.env['VAR_NAME'] or process.env[\"VAR_NAME\"]\n  if (\n    node.type === 'MemberExpression' &&\n    isProcessEnv(node.object) &&\n    node.computed &&\n    node.property.type === 'Literal' &&\n    typeof node.property.value === 'string'\n  ) {\n    const name = node.property.value;\n    return {\n      name,\n      file,\n      line: node.loc?.start.line ?? 0,\n      column: node.loc?.start.column ?? 0,\n      accessPattern: 'bracket',\n      isClientSide: isClientFile || isClientVariable(name, clientPrefixes),\n      inferredType: inferTypeFromContext(node),\n    };\n  }\n\n  // Pattern 3: Destructuring - const { VAR } = process.env\n  if (\n    node.type === 'VariableDeclarator' &&\n    node.id.type === 'ObjectPattern' &&\n    node.init &&\n    isProcessEnvNode(node.init)\n  ) {\n    const usages: EnvUsage[] = [];\n    for (const prop of node.id.properties) {\n      if (prop.type === 'Property' && prop.key.type === 'Identifier') {\n        const name = prop.key.name;\n        usages.push({\n          name,\n          file,\n          line: prop.loc?.start.line ?? 0,\n          column: prop.loc?.start.column ?? 0,\n          accessPattern: 'destructure',\n          isClientSide: isClientFile || isClientVariable(name, clientPrefixes),\n        });\n      }\n    }\n    // Return first usage (we'll handle this differently in the walk)\n    return usages[0] || null;\n  }\n\n  // Pattern 4: Dynamic access - process.env[variable]\n  if (\n    node.type === 'MemberExpression' &&\n    isProcessEnv(node.object) &&\n    node.computed &&\n    node.property.type !== 'Literal'\n  ) {\n    return {\n      name: '<dynamic>',\n      file,\n      line: node.loc?.start.line ?? 0,\n      column: node.loc?.start.column ?? 0,\n      accessPattern: 'dynamic',\n      isClientSide: isClientFile,\n    };\n  }\n\n  // Pattern 5: import.meta.env.VAR (Vite)\n  if (\n    node.type === 'MemberExpression' &&\n    isImportMetaEnv(node.object) &&\n    node.property.type === 'Identifier'\n  ) {\n    const name = node.property.name;\n    return {\n      name,\n      file,\n      line: node.loc?.start.line ?? 0,\n      column: node.loc?.start.column ?? 0,\n      accessPattern: 'direct',\n      isClientSide: true, // import.meta.env is always client-side in Vite\n    };\n  }\n\n  return null;\n}\n\n/**\n * Check if a node is process.env\n */\nfunction isProcessEnv(node: TSESTree.Node): boolean {\n  return (\n    node.type === 'MemberExpression' &&\n    node.object.type === 'Identifier' &&\n    node.object.name === 'process' &&\n    node.property.type === 'Identifier' &&\n    node.property.name === 'env'\n  );\n}\n\n/**\n * Check if a node is the process.env object\n */\nfunction isProcessEnvNode(node: TSESTree.Node): boolean {\n  return isProcessEnv(node as TSESTree.MemberExpression);\n}\n\n/**\n * Check if a node is import.meta.env\n */\nfunction isImportMetaEnv(node: TSESTree.Node): boolean {\n  return (\n    node.type === 'MemberExpression' &&\n    node.object.type === 'MetaProperty' &&\n    node.object.meta.name === 'import' &&\n    node.object.property.name === 'meta' &&\n    node.property.type === 'Identifier' &&\n    node.property.name === 'env'\n  );\n}\n\n/**\n * Infer type from usage context\n */\nfunction inferTypeFromContext(\n  node: TSESTree.Node\n): 'string' | 'number' | 'boolean' | 'json' | 'array' | undefined {\n  // Check parent nodes for type hints\n  const parent = (node as TSESTree.Node & { parent?: TSESTree.Node }).parent;\n  if (!parent) return undefined;\n\n  // parseInt(process.env.PORT) or Number(process.env.PORT)\n  if (\n    parent.type === 'CallExpression' &&\n    parent.callee.type === 'Identifier' &&\n    ['parseInt', 'parseFloat', 'Number'].includes(parent.callee.name)\n  ) {\n    return 'number';\n  }\n\n  // process.env.VAR === 'true' or Boolean(process.env.VAR)\n  if (\n    parent.type === 'BinaryExpression' &&\n    parent.right.type === 'Literal' &&\n    (parent.right.value === 'true' || parent.right.value === 'false')\n  ) {\n    return 'boolean';\n  }\n\n  // JSON.parse(process.env.VAR)\n  if (\n    parent.type === 'CallExpression' &&\n    parent.callee.type === 'MemberExpression' &&\n    parent.callee.object.type === 'Identifier' &&\n    parent.callee.object.name === 'JSON' &&\n    parent.callee.property.type === 'Identifier' &&\n    parent.callee.property.name === 'parse'\n  ) {\n    return 'json';\n  }\n\n  // process.env.VAR.split(',')\n  if (\n    parent.type === 'MemberExpression' &&\n    parent.property.type === 'Identifier' &&\n    parent.property.name === 'split'\n  ) {\n    return 'array';\n  }\n\n  return undefined;\n}\n\n/**\n * Check if a variable is client-side based on prefix\n */\nfunction isClientVariable(name: string, prefixes: string[]): boolean {\n  return prefixes.some((prefix) => name.startsWith(prefix));\n}\n\n/**\n * Check if a file is likely client-side\n */\nfunction isClientSideFile(filePath: string): boolean {\n  const clientPatterns = [\n    /\\/components\\//,\n    /\\/pages\\//,\n    /\\/app\\/.*page\\.(tsx?|jsx?)$/,\n    /\\/hooks\\//,\n    /\\.client\\.(tsx?|jsx?)$/,\n  ];\n\n  return clientPatterns.some((pattern) => pattern.test(filePath));\n}\n\n/**\n * Walk AST and call visitor for each node\n */\nfunction walkAST(node: TSESTree.Node, visitor: (node: TSESTree.Node) => void): void {\n  visitor(node);\n\n  for (const key of Object.keys(node)) {\n    const value = (node as unknown as Record<string, unknown>)[key];\n\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (item && typeof item === 'object' && 'type' in item) {\n          walkAST(item as TSESTree.Node, visitor);\n        }\n      }\n    } else if (value && typeof value === 'object' && 'type' in value) {\n      walkAST(value as TSESTree.Node, visitor);\n    }\n  }\n}\n\n/**\n * Fallback regex-based scanning\n */\nfunction scanWithRegex(\n  content: string,\n  file: string,\n  isClientFile: boolean,\n  clientPrefixes: string[]\n): EnvUsage[] {\n  const usages: EnvUsage[] = [];\n  const lines = content.split('\\n');\n\n  // Pattern for process.env.VAR_NAME\n  const directPattern = /process\\.env\\.([A-Z_][A-Z0-9_]*)/g;\n\n  // Pattern for process.env['VAR_NAME'] or process.env[\"VAR_NAME\"]\n  const bracketPattern = /process\\.env\\[['\"]([A-Z_][A-Z0-9_]*)['\"]\\]/g;\n\n  // Pattern for import.meta.env.VAR_NAME\n  const vitePattern = /import\\.meta\\.env\\.([A-Z_][A-Z0-9_]*)/g;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineNumber = i + 1;\n\n    // Direct access\n    let match;\n    while ((match = directPattern.exec(line)) !== null) {\n      usages.push({\n        name: match[1],\n        file,\n        line: lineNumber,\n        column: match.index,\n        accessPattern: 'direct',\n        isClientSide: isClientFile || isClientVariable(match[1], clientPrefixes),\n      });\n    }\n\n    // Bracket access\n    while ((match = bracketPattern.exec(line)) !== null) {\n      usages.push({\n        name: match[1],\n        file,\n        line: lineNumber,\n        column: match.index,\n        accessPattern: 'bracket',\n        isClientSide: isClientFile || isClientVariable(match[1], clientPrefixes),\n      });\n    }\n\n    // Vite access\n    while ((match = vitePattern.exec(line)) !== null) {\n      usages.push({\n        name: match[1],\n        file,\n        line: lineNumber,\n        column: match.index,\n        accessPattern: 'direct',\n        isClientSide: true,\n      });\n    }\n  }\n\n  return usages;\n}\n\n/**\n * Extract all unique variable names from usages\n */\nexport function getUniqueVariableNames(usages: EnvUsage[]): string[] {\n  const names = new Set<string>();\n  for (const usage of usages) {\n    if (usage.name !== '<dynamic>') {\n      names.add(usage.name);\n    }\n  }\n  return Array.from(names);\n}\n\n","import { glob } from 'glob';\nimport { resolve } from 'node:path';\n\nexport interface GlobOptions {\n  /** Root directory to search from */\n  cwd: string;\n  /** Patterns to include */\n  include: string[];\n  /** Patterns to exclude */\n  exclude: string[];\n  /** Follow symlinks */\n  followSymlinks?: boolean;\n}\n\n/**\n * Find files matching glob patterns\n */\nexport async function findFiles(options: GlobOptions): Promise<string[]> {\n  const { cwd, include, exclude, followSymlinks = false } = options;\n\n  const files = await glob(include, {\n    cwd,\n    ignore: exclude,\n    absolute: true,\n    nodir: true,\n    follow: followSymlinks,\n  });\n\n  return files.map((f) => resolve(f));\n}\n\n/**\n * Check if a path matches any of the given patterns\n */\nexport function matchesPattern(path: string, patterns: string[]): boolean {\n  for (const pattern of patterns) {\n    // Simple wildcard matching for now\n    if (pattern.endsWith('*')) {\n      const prefix = pattern.slice(0, -1);\n      if (path.startsWith(prefix)) {\n        return true;\n      }\n    } else if (path === pattern || path.includes(pattern)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Check if a variable name matches ignore patterns\n */\nexport function shouldIgnoreVariable(\n  variable: string,\n  ignorePatterns: string[],\n  ruleType?: string\n): boolean {\n  for (const pattern of ignorePatterns) {\n    // Check for rule-specific ignore (e.g., \"unused:DEBUG\")\n    if (pattern.includes(':')) {\n      const [rule, varPattern] = pattern.split(':');\n      if (ruleType && rule === ruleType) {\n        if (matchesVariablePattern(variable, varPattern)) {\n          return true;\n        }\n      }\n    } else {\n      // Check general variable pattern\n      if (matchesVariablePattern(variable, pattern)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Match a variable name against a pattern with wildcard support\n */\nfunction matchesVariablePattern(variable: string, pattern: string): boolean {\n  if (pattern.endsWith('*')) {\n    return variable.startsWith(pattern.slice(0, -1));\n  }\n  if (pattern.startsWith('*')) {\n    return variable.endsWith(pattern.slice(1));\n  }\n  return variable === pattern;\n}\n\n","import { resolve } from 'node:path';\nimport type { Framework } from '../types/index.js';\nimport { fileExists, readJsonFile } from '../utils/fs.js';\nimport { logger } from '../utils/logger.js';\n\nexport interface FrameworkInfo {\n  name: Framework;\n  displayName: string;\n  envPrefix: string[];\n  clientPrefix: string[];\n  serverOnly: boolean;\n  configFiles: string[];\n}\n\n/**\n * Framework definitions\n */\nexport const FRAMEWORKS: Record<Exclude<Framework, 'auto'>, FrameworkInfo> = {\n  nextjs: {\n    name: 'nextjs',\n    displayName: 'Next.js',\n    envPrefix: ['NEXT_PUBLIC_'],\n    clientPrefix: ['NEXT_PUBLIC_'],\n    serverOnly: false,\n    configFiles: ['next.config.js', 'next.config.mjs', 'next.config.ts'],\n  },\n  vite: {\n    name: 'vite',\n    displayName: 'Vite',\n    envPrefix: ['VITE_'],\n    clientPrefix: ['VITE_'],\n    serverOnly: false,\n    configFiles: ['vite.config.js', 'vite.config.ts', 'vite.config.mjs'],\n  },\n  cra: {\n    name: 'cra',\n    displayName: 'Create React App',\n    envPrefix: ['REACT_APP_'],\n    clientPrefix: ['REACT_APP_'],\n    serverOnly: false,\n    configFiles: [],\n  },\n  node: {\n    name: 'node',\n    displayName: 'Node.js',\n    envPrefix: [],\n    clientPrefix: [],\n    serverOnly: true,\n    configFiles: [],\n  },\n};\n\n/**\n * Auto-detect the framework used in a project\n */\nexport async function detectFramework(rootDir: string): Promise<Framework> {\n  logger.debug('Auto-detecting framework...');\n\n  // Check for framework-specific config files\n  for (const [framework, info] of Object.entries(FRAMEWORKS)) {\n    for (const configFile of info.configFiles) {\n      const configPath = resolve(rootDir, configFile);\n      if (await fileExists(configPath)) {\n        logger.debug(`Detected ${info.displayName} via ${configFile}`);\n        return framework as Framework;\n      }\n    }\n  }\n\n  // Check package.json dependencies\n  const packageJsonPath = resolve(rootDir, 'package.json');\n  const packageJson = await readJsonFile<{\n    dependencies?: Record<string, string>;\n    devDependencies?: Record<string, string>;\n  }>(packageJsonPath);\n\n  if (packageJson) {\n    const allDeps = {\n      ...packageJson.dependencies,\n      ...packageJson.devDependencies,\n    };\n\n    // Check for Next.js\n    if ('next' in allDeps) {\n      logger.debug('Detected Next.js via package.json');\n      return 'nextjs';\n    }\n\n    // Check for Vite\n    if ('vite' in allDeps) {\n      logger.debug('Detected Vite via package.json');\n      return 'vite';\n    }\n\n    // Check for Create React App\n    if ('react-scripts' in allDeps) {\n      logger.debug('Detected Create React App via package.json');\n      return 'cra';\n    }\n  }\n\n  // Default to Node.js\n  logger.debug('No specific framework detected, defaulting to Node.js');\n  return 'node';\n}\n\n/**\n * Get framework info\n */\nexport function getFrameworkInfo(framework: Framework): FrameworkInfo {\n  if (framework === 'auto') {\n    return FRAMEWORKS.node;\n  }\n  return FRAMEWORKS[framework];\n}\n\n/**\n * Check if a variable should be client-accessible for a framework\n */\nexport function isClientAccessible(variable: string, framework: Framework): boolean {\n  const info = getFrameworkInfo(framework);\n\n  if (info.serverOnly) {\n    return false;\n  }\n\n  return info.clientPrefix.some((prefix) => variable.startsWith(prefix));\n}\n\n/**\n * Get the expected env file patterns for a framework\n */\nexport function getEnvFilePatterns(framework: Framework): string[] {\n  const baseFiles = ['.env', '.env.local'];\n\n  switch (framework) {\n    case 'nextjs':\n      return [\n        ...baseFiles,\n        '.env.development',\n        '.env.development.local',\n        '.env.production',\n        '.env.production.local',\n        '.env.test',\n        '.env.test.local',\n      ];\n    case 'vite':\n      return [\n        ...baseFiles,\n        '.env.development',\n        '.env.development.local',\n        '.env.production',\n        '.env.production.local',\n      ];\n    case 'cra':\n      return [\n        ...baseFiles,\n        '.env.development',\n        '.env.development.local',\n        '.env.production',\n        '.env.production.local',\n        '.env.test',\n        '.env.test.local',\n      ];\n    default:\n      return baseFiles;\n  }\n}\n\n/**\n * Validate that a variable follows framework conventions\n */\nexport function validateFrameworkConvention(\n  variable: string,\n  framework: Framework,\n  isClientSide: boolean\n): { valid: boolean; message?: string } {\n  const info = getFrameworkInfo(framework);\n\n  if (info.serverOnly) {\n    return { valid: true };\n  }\n\n  const hasClientPrefix = info.clientPrefix.some((prefix) => variable.startsWith(prefix));\n\n  if (isClientSide && !hasClientPrefix) {\n    return {\n      valid: false,\n      message: `Variable \"${variable}\" is used on client-side but doesn't have required prefix (${info.clientPrefix.join(' or ')})`,\n    };\n  }\n\n  return { valid: true };\n}\n\n","import type { EnvDoctorConfig, EnvVariable, EnvUsage, Issue } from '../types/index.js';\nimport { shouldIgnoreVariable } from '../utils/glob.js';\n\nexport interface MissingAnalyzerOptions {\n  /** Variables defined in .env files */\n  definedVariables: EnvVariable[];\n  /** Variables used in code */\n  usedVariables: EnvUsage[];\n  /** Configuration */\n  config: EnvDoctorConfig;\n}\n\n/**\n * Find variables that are used in code but not defined in .env files\n */\nexport function analyzeMissing(options: MissingAnalyzerOptions): Issue[] {\n  const { definedVariables, usedVariables, config } = options;\n  const issues: Issue[] = [];\n\n  // Create a set of defined variable names\n  const definedNames = new Set(definedVariables.map((v) => v.name));\n\n  // Track which variables we've already reported\n  const reported = new Set<string>();\n\n  // Find all unique used variable names\n  for (const usage of usedVariables) {\n    const { name } = usage;\n\n    // Skip dynamic access\n    if (name === '<dynamic>') {\n      continue;\n    }\n\n    // Skip if already reported\n    if (reported.has(name)) {\n      continue;\n    }\n\n    // Skip if defined\n    if (definedNames.has(name)) {\n      continue;\n    }\n\n    // Skip if ignored\n    if (shouldIgnoreVariable(name, config.ignore, 'missing')) {\n      continue;\n    }\n\n    // Check if variable has a default value in config\n    const varConfig = config.variables[name];\n    if (varConfig?.default !== undefined) {\n      continue;\n    }\n\n    // Determine severity based on config\n    const isRequired = varConfig?.required ?? false;\n    const severity = isRequired ? 'error' : 'warning';\n\n    reported.add(name);\n\n    issues.push({\n      type: 'missing',\n      severity,\n      variable: name,\n      message: `Variable \"${name}\" is used in code but not defined in any .env file`,\n      location: {\n        file: usage.file,\n        line: usage.line,\n        column: usage.column,\n      },\n      fix: `Add ${name}= to your .env file`,\n    });\n  }\n\n  // Also check for explicitly required variables from config\n  for (const [name, rule] of Object.entries(config.variables)) {\n    if (!rule.required) continue;\n    if (definedNames.has(name)) continue;\n    if (reported.has(name)) continue;\n    if (shouldIgnoreVariable(name, config.ignore, 'missing')) continue;\n\n    reported.add(name);\n\n    issues.push({\n      type: 'missing',\n      severity: 'error',\n      variable: name,\n      message: `Required variable \"${name}\" is not defined in any .env file`,\n      fix: `Add ${name}= to your .env file`,\n    });\n  }\n\n  return issues;\n}\n\n/**\n * Get a summary of missing variables\n */\nexport function getMissingSummary(issues: Issue[]): {\n  required: string[];\n  optional: string[];\n} {\n  const required: string[] = [];\n  const optional: string[] = [];\n\n  for (const issue of issues) {\n    if (issue.type !== 'missing') continue;\n\n    if (issue.severity === 'error') {\n      required.push(issue.variable);\n    } else {\n      optional.push(issue.variable);\n    }\n  }\n\n  return { required, optional };\n}\n\n","import type { EnvDoctorConfig, EnvVariable, EnvUsage, Issue } from '../types/index.js';\nimport { shouldIgnoreVariable } from '../utils/glob.js';\n\nexport interface UnusedAnalyzerOptions {\n  /** Variables defined in .env files */\n  definedVariables: EnvVariable[];\n  /** Variables used in code */\n  usedVariables: EnvUsage[];\n  /** Configuration */\n  config: EnvDoctorConfig;\n  /** Framework for checking special variables */\n  framework: string;\n}\n\n/**\n * Common variables that are typically used by the runtime/framework\n */\nconst COMMON_RUNTIME_VARS = new Set([\n  'NODE_ENV',\n  'PORT',\n  'HOST',\n  'DEBUG',\n  'LOG_LEVEL',\n  'TZ',\n  'CI',\n  'HOME',\n  'PATH',\n  'SHELL',\n  'USER',\n  'TERM',\n]);\n\n/**\n * Framework-specific variables that are used by the framework itself\n */\nconst FRAMEWORK_VARS: Record<string, Set<string>> = {\n  nextjs: new Set([\n    'NEXT_TELEMETRY_DISABLED',\n    'NEXT_RUNTIME',\n    'VERCEL',\n    'VERCEL_ENV',\n    'VERCEL_URL',\n    'VERCEL_REGION',\n  ]),\n  vite: new Set(['VITE_CJS_TRACE', 'VITE_CJS_IGNORE_WARNING']),\n  cra: new Set(['BROWSER', 'GENERATE_SOURCEMAP', 'CI']),\n  node: new Set([]),\n};\n\n/**\n * Find variables that are defined in .env files but never used in code\n */\nexport function analyzeUnused(options: UnusedAnalyzerOptions): Issue[] {\n  const { definedVariables, usedVariables, config, framework } = options;\n  const issues: Issue[] = [];\n\n  // Create a set of used variable names\n  const usedNames = new Set(\n    usedVariables.filter((u) => u.name !== '<dynamic>').map((u) => u.name)\n  );\n\n  // Get framework-specific allowed variables\n  const frameworkVars = FRAMEWORK_VARS[framework] || new Set();\n\n  for (const variable of definedVariables) {\n    const { name, file, line } = variable;\n\n    // Skip if used\n    if (usedNames.has(name)) {\n      continue;\n    }\n\n    // Skip common runtime variables\n    if (COMMON_RUNTIME_VARS.has(name)) {\n      continue;\n    }\n\n    // Skip framework-specific variables\n    if (frameworkVars.has(name)) {\n      continue;\n    }\n\n    // Skip if ignored\n    if (shouldIgnoreVariable(name, config.ignore, 'unused')) {\n      continue;\n    }\n\n    // Skip if it's a placeholder/example value\n    if (isPlaceholderValue(variable.value)) {\n      continue;\n    }\n\n    issues.push({\n      type: 'unused',\n      severity: 'warning',\n      variable: name,\n      message: `Variable \"${name}\" is defined in ${file} but never used in code`,\n      location: {\n        file,\n        line,\n      },\n      context: {\n        value: variable.value ? '[set]' : '[empty]',\n      },\n    });\n  }\n\n  return issues;\n}\n\n/**\n * Check if a value looks like a placeholder\n */\nfunction isPlaceholderValue(value: string): boolean {\n  if (!value) return true;\n\n  const placeholderPatterns = [\n    /^your[-_]?/i,\n    /^xxx+$/i,\n    /^placeholder$/i,\n    /^changeme$/i,\n    /^todo$/i,\n    /^<.*>$/,\n    /^\\[.*\\]$/,\n    /^example[-_]?/i,\n  ];\n\n  return placeholderPatterns.some((pattern) => pattern.test(value));\n}\n\n/**\n * Get a summary of unused variables\n */\nexport function getUnusedSummary(issues: Issue[]): {\n  count: number;\n  byFile: Record<string, string[]>;\n} {\n  const byFile: Record<string, string[]> = {};\n  let count = 0;\n\n  for (const issue of issues) {\n    if (issue.type !== 'unused') continue;\n\n    count++;\n    const file = issue.location?.file || 'unknown';\n\n    if (!byFile[file]) {\n      byFile[file] = [];\n    }\n    byFile[file].push(issue.variable);\n  }\n\n  return { count, byFile };\n}\n\n","import type { EnvDoctorConfig, EnvVariable, EnvUsage, Issue, VariableType } from '../types/index.js';\nimport { shouldIgnoreVariable } from '../utils/glob.js';\nimport { inferValueType } from '../scanner/env-parser.js';\n\nexport interface TypeMismatchAnalyzerOptions {\n  /** Variables defined in .env files */\n  definedVariables: EnvVariable[];\n  /** Variables used in code */\n  usedVariables: EnvUsage[];\n  /** Configuration */\n  config: EnvDoctorConfig;\n}\n\n/**\n * Find variables where the value doesn't match the expected or inferred type\n */\nexport function analyzeTypeMismatch(options: TypeMismatchAnalyzerOptions): Issue[] {\n  const { definedVariables, usedVariables, config } = options;\n  const issues: Issue[] = [];\n\n  // Create a map of defined variables by name\n  const definedMap = new Map<string, EnvVariable>();\n  for (const variable of definedVariables) {\n    definedMap.set(variable.name, variable);\n  }\n\n  // Group usages by variable name\n  const usagesByName = new Map<string, EnvUsage[]>();\n  for (const usage of usedVariables) {\n    if (usage.name === '<dynamic>') continue;\n\n    const existing = usagesByName.get(usage.name) || [];\n    existing.push(usage);\n    usagesByName.set(usage.name, existing);\n  }\n\n  // Track checked variables to avoid duplicates\n  const checked = new Set<string>();\n\n  for (const [name, usages] of usagesByName) {\n    if (checked.has(name)) continue;\n    checked.add(name);\n\n    // Skip if ignored\n    if (shouldIgnoreVariable(name, config.ignore, 'type-mismatch')) {\n      continue;\n    }\n\n    const defined = definedMap.get(name);\n    if (!defined) continue; // Missing variables handled elsewhere\n\n    const value = defined.value;\n\n    // Check explicit type from config\n    const varConfig = config.variables[name];\n    if (varConfig?.type) {\n      const typeIssue = validateType(name, value, varConfig.type, defined);\n      if (typeIssue) {\n        issues.push(typeIssue);\n        continue;\n      }\n    }\n\n    // Check pattern from config\n    if (varConfig?.pattern) {\n      if (!varConfig.pattern.test(value)) {\n        issues.push({\n          type: 'invalid-value',\n          severity: 'error',\n          variable: name,\n          message: `Value of \"${name}\" doesn't match required pattern`,\n          location: {\n            file: defined.file,\n            line: defined.line,\n          },\n          context: {\n            pattern: varConfig.pattern.toString(),\n            value: maskSensitiveValue(value, defined.isSecret),\n          },\n        });\n        continue;\n      }\n    }\n\n    // Check enum from config\n    if (varConfig?.enum && varConfig.enum.length > 0) {\n      if (!varConfig.enum.includes(value)) {\n        issues.push({\n          type: 'invalid-value',\n          severity: 'error',\n          variable: name,\n          message: `Value of \"${name}\" must be one of: ${varConfig.enum.join(', ')}`,\n          location: {\n            file: defined.file,\n            line: defined.line,\n          },\n          context: {\n            expected: varConfig.enum,\n            actual: maskSensitiveValue(value, defined.isSecret),\n          },\n        });\n        continue;\n      }\n    }\n\n    // Infer type from usage and validate\n    const inferredTypes = usages\n      .map((u) => u.inferredType)\n      .filter((t): t is NonNullable<typeof t> => t !== undefined);\n\n    if (inferredTypes.length > 0) {\n      // Use the most common inferred type\n      const primaryType = getMostCommonType(inferredTypes);\n\n      if (primaryType) {\n        const typeIssue = validateInferredType(name, value, primaryType, defined, usages[0]);\n        if (typeIssue) {\n          issues.push(typeIssue);\n        }\n      }\n    }\n  }\n\n  return issues;\n}\n\n/**\n * Validate a value against an explicit type\n */\nfunction validateType(\n  name: string,\n  value: string,\n  type: VariableType,\n  defined: EnvVariable\n): Issue | null {\n  switch (type) {\n    case 'number':\n      if (!/^-?\\d+(\\.\\d+)?$/.test(value)) {\n        return {\n          type: 'type-mismatch',\n          severity: 'error',\n          variable: name,\n          message: `Variable \"${name}\" should be a number but value \"${maskSensitiveValue(value, defined.isSecret)}\" is not numeric`,\n          location: { file: defined.file, line: defined.line },\n          fix: 'Update the value to be a valid number',\n        };\n      }\n      break;\n\n    case 'boolean':\n      if (!['true', 'false', '1', '0', 'yes', 'no'].includes(value.toLowerCase())) {\n        return {\n          type: 'type-mismatch',\n          severity: 'error',\n          variable: name,\n          message: `Variable \"${name}\" should be a boolean but value \"${maskSensitiveValue(value, defined.isSecret)}\" is not valid`,\n          location: { file: defined.file, line: defined.line },\n          fix: 'Use true, false, 1, 0, yes, or no',\n        };\n      }\n      break;\n\n    case 'json':\n      try {\n        JSON.parse(value);\n      } catch {\n        return {\n          type: 'type-mismatch',\n          severity: 'error',\n          variable: name,\n          message: `Variable \"${name}\" should be valid JSON but value is not parseable`,\n          location: { file: defined.file, line: defined.line },\n          fix: 'Ensure the value is valid JSON',\n        };\n      }\n      break;\n\n    case 'url':\n      try {\n        new URL(value);\n      } catch {\n        return {\n          type: 'type-mismatch',\n          severity: 'error',\n          variable: name,\n          message: `Variable \"${name}\" should be a valid URL`,\n          location: { file: defined.file, line: defined.line },\n          fix: 'Provide a valid URL (e.g., https://example.com)',\n        };\n      }\n      break;\n\n    case 'email':\n      if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n        return {\n          type: 'type-mismatch',\n          severity: 'error',\n          variable: name,\n          message: `Variable \"${name}\" should be a valid email address`,\n          location: { file: defined.file, line: defined.line },\n          fix: 'Provide a valid email address',\n        };\n      }\n      break;\n  }\n\n  return null;\n}\n\n/**\n * Validate a value against an inferred type from usage\n */\nfunction validateInferredType(\n  name: string,\n  value: string,\n  inferredType: string,\n  defined: EnvVariable,\n  usage: EnvUsage\n): Issue | null {\n  const actualType = inferValueType(value);\n\n  // Skip if value is empty (might be intentional)\n  if (!value) return null;\n\n  switch (inferredType) {\n    case 'number':\n      if (actualType !== 'number') {\n        return {\n          type: 'type-mismatch',\n          severity: 'warning',\n          variable: name,\n          message: `Variable \"${name}\" is used as a number at ${usage.file}:${usage.line} but value \"${maskSensitiveValue(value, defined.isSecret)}\" is not numeric`,\n          location: { file: defined.file, line: defined.line },\n          context: {\n            usedAt: `${usage.file}:${usage.line}`,\n          },\n        };\n      }\n      break;\n\n    case 'boolean':\n      if (!['true', 'false', '1', '0'].includes(value.toLowerCase())) {\n        return {\n          type: 'type-mismatch',\n          severity: 'warning',\n          variable: name,\n          message: `Variable \"${name}\" is used as a boolean at ${usage.file}:${usage.line} but value may not be valid`,\n          location: { file: defined.file, line: defined.line },\n          context: {\n            usedAt: `${usage.file}:${usage.line}`,\n          },\n        };\n      }\n      break;\n\n    case 'json':\n      if (actualType !== 'json') {\n        try {\n          JSON.parse(value);\n        } catch {\n          return {\n            type: 'type-mismatch',\n            severity: 'warning',\n            variable: name,\n            message: `Variable \"${name}\" is parsed as JSON at ${usage.file}:${usage.line} but value is not valid JSON`,\n            location: { file: defined.file, line: defined.line },\n            context: {\n              usedAt: `${usage.file}:${usage.line}`,\n            },\n          };\n        }\n      }\n      break;\n\n    case 'array':\n      // Arrays are typically split by comma, so any value with commas is probably fine\n      if (!value.includes(',')) {\n        return {\n          type: 'type-mismatch',\n          severity: 'info',\n          variable: name,\n          message: `Variable \"${name}\" is used as an array at ${usage.file}:${usage.line} but value doesn't contain comma separators`,\n          location: { file: defined.file, line: defined.line },\n          context: {\n            usedAt: `${usage.file}:${usage.line}`,\n          },\n        };\n      }\n      break;\n  }\n\n  return null;\n}\n\n/**\n * Get the most common type from an array\n */\nfunction getMostCommonType(types: string[]): string | undefined {\n  const counts: Record<string, number> = {};\n  for (const type of types) {\n    counts[type] = (counts[type] || 0) + 1;\n  }\n\n  let maxCount = 0;\n  let maxType: string | undefined;\n  for (const [type, count] of Object.entries(counts)) {\n    if (count > maxCount) {\n      maxCount = count;\n      maxType = type;\n    }\n  }\n\n  return maxType;\n}\n\n/**\n * Mask sensitive values for display\n */\nfunction maskSensitiveValue(value: string, isSecret?: boolean): string {\n  if (!isSecret) return value;\n\n  if (value.length <= 4) return '****';\n  return value.slice(0, 2) + '****' + value.slice(-2);\n}\n\n","import type { EnvVariable, Issue } from '../types/index.js';\n\nexport interface SyncCheckOptions {\n  /** Variables defined in .env files */\n  envVariables: EnvVariable[];\n  /** Variables defined in template file (.env.example) */\n  templateVariables: EnvVariable[];\n  /** Template file name */\n  templateFile: string;\n}\n\nexport interface SyncCheckResult {\n  /** Issues found */\n  issues: Issue[];\n  /** Variables in env but not in template */\n  missingFromTemplate: string[];\n  /** Variables in template but not in env */\n  missingFromEnv: string[];\n  /** Whether files are in sync */\n  inSync: boolean;\n}\n\n/**\n * Check if .env files are in sync with the template file\n */\nexport function analyzeSyncDrift(options: SyncCheckOptions): SyncCheckResult {\n  const { envVariables, templateVariables, templateFile } = options;\n  const issues: Issue[] = [];\n\n  // Create sets of variable names\n  const envNames = new Set(envVariables.map((v) => v.name));\n  const templateNames = new Set(templateVariables.map((v) => v.name));\n\n  const missingFromTemplate: string[] = [];\n  const missingFromEnv: string[] = [];\n\n  // Find variables in env but not in template\n  for (const variable of envVariables) {\n    if (!templateNames.has(variable.name)) {\n      missingFromTemplate.push(variable.name);\n\n      issues.push({\n        type: 'sync-drift',\n        severity: 'warning',\n        variable: variable.name,\n        message: `Variable \"${variable.name}\" is defined in ${variable.file} but not in ${templateFile}`,\n        location: {\n          file: variable.file,\n          line: variable.line,\n        },\n        fix: `Add ${variable.name}= to ${templateFile}`,\n      });\n    }\n  }\n\n  // Find variables in template but not in env\n  for (const variable of templateVariables) {\n    if (!envNames.has(variable.name)) {\n      missingFromEnv.push(variable.name);\n\n      issues.push({\n        type: 'sync-drift',\n        severity: 'info',\n        variable: variable.name,\n        message: `Variable \"${variable.name}\" is in ${templateFile} but not defined in any .env file`,\n        location: {\n          file: templateFile,\n          line: variable.line,\n        },\n        fix: `Add ${variable.name}= to your .env file`,\n      });\n    }\n  }\n\n  const inSync = missingFromTemplate.length === 0 && missingFromEnv.length === 0;\n\n  return {\n    issues,\n    missingFromTemplate,\n    missingFromEnv,\n    inSync,\n  };\n}\n\n/**\n * Generate a template file content from env variables\n */\nexport function generateTemplate(\n  variables: EnvVariable[],\n  options: {\n    includeComments?: boolean;\n    groupByPrefix?: boolean;\n    maskSecrets?: boolean;\n  } = {}\n): string {\n  const { includeComments = true, groupByPrefix = true, maskSecrets = true } = options;\n\n  const lines: string[] = [];\n\n  if (includeComments) {\n    lines.push('# Environment Variables Template');\n    lines.push('# Copy this file to .env and fill in the values');\n    lines.push('');\n  }\n\n  if (groupByPrefix) {\n    // Group variables by prefix\n    const groups: Record<string, EnvVariable[]> = {};\n\n    for (const variable of variables) {\n      const prefix = getPrefix(variable.name);\n      if (!groups[prefix]) {\n        groups[prefix] = [];\n      }\n      groups[prefix].push(variable);\n    }\n\n    // Sort groups\n    const sortedGroups = Object.entries(groups).sort(([a], [b]) => a.localeCompare(b));\n\n    for (const [prefix, vars] of sortedGroups) {\n      if (includeComments && prefix) {\n        lines.push(`# ${formatPrefixName(prefix)}`);\n      }\n\n      for (const variable of vars.sort((a, b) => a.name.localeCompare(b.name))) {\n        lines.push(formatTemplateVariable(variable, maskSecrets));\n      }\n\n      lines.push('');\n    }\n  } else {\n    // Simple alphabetical listing\n    const sorted = [...variables].sort((a, b) => a.name.localeCompare(b.name));\n\n    for (const variable of sorted) {\n      lines.push(formatTemplateVariable(variable, maskSecrets));\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Get the prefix of a variable name\n */\nfunction getPrefix(name: string): string {\n  // Common prefixes\n  const prefixes = [\n    'NEXT_PUBLIC_',\n    'REACT_APP_',\n    'VITE_',\n    'DATABASE_',\n    'DB_',\n    'REDIS_',\n    'AWS_',\n    'STRIPE_',\n    'AUTH_',\n    'API_',\n    'APP_',\n  ];\n\n  for (const prefix of prefixes) {\n    if (name.startsWith(prefix)) {\n      return prefix;\n    }\n  }\n\n  // Try to find a prefix by underscore\n  const parts = name.split('_');\n  if (parts.length > 1) {\n    return parts[0] + '_';\n  }\n\n  return '';\n}\n\n/**\n * Format a prefix name for display\n */\nfunction formatPrefixName(prefix: string): string {\n  return prefix\n    .replace(/_$/, '')\n    .replace(/_/g, ' ')\n    .toLowerCase()\n    .replace(/\\b\\w/g, (c) => c.toUpperCase());\n}\n\n/**\n * Format a variable for the template file\n */\nfunction formatTemplateVariable(variable: EnvVariable, maskSecrets: boolean): string {\n  let value = '';\n\n  if (variable.value && !maskSecrets) {\n    value = variable.value;\n  } else if (variable.isSecret) {\n    value = ''; // Leave empty for secrets\n  } else if (variable.value) {\n    // For non-secrets, include a hint or example value\n    value = getExampleValue(variable);\n  }\n\n  return `${variable.name}=${value}`;\n}\n\n/**\n * Get an example value for a variable\n */\nfunction getExampleValue(variable: EnvVariable): string {\n  const { name, value } = variable;\n\n  // If it looks like a URL, show the format\n  if (name.includes('URL') || name.includes('URI')) {\n    if (value.startsWith('postgres://')) return 'postgres://user:pass@localhost:5432/db';\n    if (value.startsWith('mysql://')) return 'mysql://user:pass@localhost:3306/db';\n    if (value.startsWith('mongodb://')) return 'mongodb://localhost:27017/db';\n    if (value.startsWith('redis://')) return 'redis://localhost:6379';\n    if (value.startsWith('http')) return 'https://example.com';\n    return '';\n  }\n\n  // If it's a number, show example\n  if (/^\\d+$/.test(value)) {\n    return value;\n  }\n\n  // If it's a boolean, show example\n  if (['true', 'false'].includes(value.toLowerCase())) {\n    return value;\n  }\n\n  // For NODE_ENV\n  if (name === 'NODE_ENV') {\n    return 'development';\n  }\n\n  return '';\n}\n\n/**\n * Merge template variables with env variables to find diff\n */\nexport function compareTemplateWithEnv(\n  template: EnvVariable[],\n  env: EnvVariable[]\n): {\n  added: string[];\n  removed: string[];\n  changed: Array<{ name: string; templateValue: string; envValue: string }>;\n} {\n  const templateMap = new Map(template.map((v) => [v.name, v]));\n  const envMap = new Map(env.map((v) => [v.name, v]));\n\n  const added: string[] = [];\n  const removed: string[] = [];\n  const changed: Array<{ name: string; templateValue: string; envValue: string }> = [];\n\n  // Find added (in env but not template)\n  for (const [name] of envMap) {\n    if (!templateMap.has(name)) {\n      added.push(name);\n    }\n  }\n\n  // Find removed (in template but not env)\n  for (const [name] of templateMap) {\n    if (!envMap.has(name)) {\n      removed.push(name);\n    }\n  }\n\n  // Find changed (different values - only for non-secret values)\n  for (const [name, envVar] of envMap) {\n    const templateVar = templateMap.get(name);\n    if (templateVar && templateVar.value && envVar.value) {\n      if (templateVar.value !== envVar.value && !envVar.isSecret) {\n        changed.push({\n          name,\n          templateValue: templateVar.value,\n          envValue: envVar.value,\n        });\n      }\n    }\n  }\n\n  return { added, removed, changed };\n}\n\n","import type { EnvVariable, Issue } from '../types/index.js';\nimport { shouldIgnoreVariable } from '../utils/glob.js';\n\n/**\n * Built-in patterns for detecting secrets\n */\nexport const SECRET_NAME_PATTERNS: Array<{ pattern: RegExp; provider?: string }> = [\n  // Generic patterns\n  { pattern: /password/i },\n  { pattern: /secret/i },\n  { pattern: /private[_-]?key/i },\n  { pattern: /api[_-]?key/i },\n  { pattern: /auth[_-]?token/i },\n  { pattern: /access[_-]?token/i },\n  { pattern: /refresh[_-]?token/i },\n  { pattern: /bearer/i },\n  { pattern: /credential/i },\n  { pattern: /connection[_-]?string/i },\n\n  // Provider-specific\n  { pattern: /^AWS_SECRET/i, provider: 'AWS' },\n  { pattern: /^AWS_ACCESS_KEY/i, provider: 'AWS' },\n  { pattern: /^STRIPE_SECRET/i, provider: 'Stripe' },\n  { pattern: /^STRIPE_WEBHOOK_SECRET/i, provider: 'Stripe' },\n  { pattern: /^GITHUB_TOKEN/i, provider: 'GitHub' },\n  { pattern: /^GH_TOKEN/i, provider: 'GitHub' },\n  { pattern: /^GOOGLE_APPLICATION_CREDENTIALS/i, provider: 'Google' },\n  { pattern: /^FIREBASE_/i, provider: 'Firebase' },\n  { pattern: /^TWILIO_AUTH_TOKEN/i, provider: 'Twilio' },\n  { pattern: /^SENDGRID_API_KEY/i, provider: 'SendGrid' },\n  { pattern: /^MAILGUN_API_KEY/i, provider: 'Mailgun' },\n  { pattern: /^SLACK_TOKEN/i, provider: 'Slack' },\n  { pattern: /^DISCORD_TOKEN/i, provider: 'Discord' },\n  { pattern: /^OPENAI_API_KEY/i, provider: 'OpenAI' },\n  { pattern: /^ANTHROPIC_API_KEY/i, provider: 'Anthropic' },\n  { pattern: /^SENTRY_DSN/i, provider: 'Sentry' },\n  { pattern: /^DATADOG_API_KEY/i, provider: 'Datadog' },\n];\n\n/**\n * Patterns for detecting secrets in values\n */\nexport const SECRET_VALUE_PATTERNS: Array<{ pattern: RegExp; type: string }> = [\n  // Stripe\n  { pattern: /^sk_live_[a-zA-Z0-9]{24,}/, type: 'Stripe live secret key' },\n  { pattern: /^sk_test_[a-zA-Z0-9]{24,}/, type: 'Stripe test secret key' },\n  { pattern: /^rk_live_[a-zA-Z0-9]{24,}/, type: 'Stripe restricted key' },\n\n  // AWS\n  { pattern: /^AKIA[A-Z0-9]{16}/, type: 'AWS access key' },\n  { pattern: /^[a-zA-Z0-9/+=]{40}$/, type: 'Possible AWS secret key' },\n\n  // GitHub\n  { pattern: /^ghp_[a-zA-Z0-9]{36}/, type: 'GitHub personal access token' },\n  { pattern: /^gho_[a-zA-Z0-9]{36}/, type: 'GitHub OAuth token' },\n  { pattern: /^ghu_[a-zA-Z0-9]{36}/, type: 'GitHub user-to-server token' },\n  { pattern: /^ghs_[a-zA-Z0-9]{36}/, type: 'GitHub server-to-server token' },\n  { pattern: /^github_pat_[a-zA-Z0-9_]{22,}/, type: 'GitHub PAT' },\n\n  // JWT\n  { pattern: /^eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*/, type: 'JWT token' },\n\n  // Private keys\n  { pattern: /-----BEGIN RSA PRIVATE KEY-----/, type: 'RSA private key' },\n  { pattern: /-----BEGIN EC PRIVATE KEY-----/, type: 'EC private key' },\n  { pattern: /-----BEGIN OPENSSH PRIVATE KEY-----/, type: 'OpenSSH private key' },\n  { pattern: /-----BEGIN PRIVATE KEY-----/, type: 'Private key' },\n\n  // Generic API keys (high entropy strings)\n  { pattern: /^[a-zA-Z0-9]{32,64}$/, type: 'Possible API key' },\n\n  // Database URLs with credentials\n  {\n    pattern: /^(postgres|postgresql|mysql|mongodb|redis):\\/\\/[^:]+:[^@]+@/,\n    type: 'Database URL with credentials',\n  },\n\n  // Google\n  { pattern: /^AIza[a-zA-Z0-9_-]{35}/, type: 'Google API key' },\n\n  // Slack\n  { pattern: /^xox[baprs]-[a-zA-Z0-9-]+/, type: 'Slack token' },\n\n  // Twilio\n  { pattern: /^AC[a-zA-Z0-9]{32}/, type: 'Twilio Account SID' },\n  { pattern: /^SK[a-zA-Z0-9]{32}/, type: 'Twilio API Key' },\n];\n\nexport interface SecretAnalyzerOptions {\n  /** Variables to analyze */\n  variables: EnvVariable[];\n  /** Additional patterns to check */\n  customPatterns?: RegExp[];\n  /** Patterns to ignore */\n  ignorePatterns?: string[];\n}\n\n/**\n * Analyze variables for potential secrets\n */\nexport function analyzeSecrets(options: SecretAnalyzerOptions): Issue[] {\n  const { variables, customPatterns = [], ignorePatterns = [] } = options;\n  const issues: Issue[] = [];\n\n  for (const variable of variables) {\n    const { name, value, file, line, isSecret } = variable;\n\n    // Skip if ignored\n    if (shouldIgnoreVariable(name, ignorePatterns, 'secret')) {\n      continue;\n    }\n\n    // Skip if already marked as secret with no value (safe)\n    if (isSecret && !value) {\n      continue;\n    }\n\n    // Check if the variable name suggests it's a secret\n    const nameMatch = findSecretNamePattern(name);\n    const valueMatch = value ? findSecretValuePattern(value) : null;\n\n    // Also check custom patterns\n    const customMatch = customPatterns.find((p) => p.test(name) || (value && p.test(value)));\n\n    if ((nameMatch || valueMatch || customMatch) && value) {\n      // This looks like a secret and has a value - potential issue\n      const provider = nameMatch?.provider;\n      const secretType = valueMatch?.type;\n\n      let message = `Variable \"${name}\" appears to be a secret`;\n      if (provider) {\n        message += ` (${provider})`;\n      }\n      if (secretType) {\n        message += ` - detected as ${secretType}`;\n      }\n\n      // Check if the value looks like a real secret (not a placeholder)\n      if (!isPlaceholderValue(value)) {\n        issues.push({\n          type: 'secret-exposed',\n          severity: 'error',\n          variable: name,\n          message: message + '. Consider using a secure vault or removing from version control.',\n          location: { file, line },\n          context: {\n            provider,\n            secretType,\n            valuePreview: redactValue(value),\n          },\n          fix: 'Use environment-specific configuration or a secrets manager',\n        });\n      }\n    }\n  }\n\n  return issues;\n}\n\n/**\n * Find matching secret name pattern\n */\nfunction findSecretNamePattern(name: string): { pattern: RegExp; provider?: string } | null {\n  for (const { pattern, provider } of SECRET_NAME_PATTERNS) {\n    if (pattern.test(name)) {\n      return { pattern, provider };\n    }\n  }\n  return null;\n}\n\n/**\n * Find matching secret value pattern\n */\nfunction findSecretValuePattern(value: string): { pattern: RegExp; type: string } | null {\n  for (const { pattern, type } of SECRET_VALUE_PATTERNS) {\n    if (pattern.test(value)) {\n      return { pattern, type };\n    }\n  }\n  return null;\n}\n\n/**\n * Check if a value looks like a placeholder\n */\nfunction isPlaceholderValue(value: string): boolean {\n  const placeholderPatterns = [\n    /^your[-_]?/i,\n    /^xxx+$/i,\n    /^placeholder$/i,\n    /^changeme$/i,\n    /^todo$/i,\n    /^<.*>$/,\n    /^\\[.*\\]$/,\n    /^example[-_]?/i,\n    /^test[-_]?/i,\n    /^dummy[-_]?/i,\n    /^fake[-_]?/i,\n    /^sample[-_]?/i,\n  ];\n\n  return placeholderPatterns.some((pattern) => pattern.test(value));\n}\n\n/**\n * Redact a secret value for display\n */\nfunction redactValue(value: string): string {\n  if (value.length <= 8) {\n    return '****';\n  }\n  return value.slice(0, 4) + '...' + value.slice(-4);\n}\n\n/**\n * Get a list of common secret variable names\n */\nexport function getCommonSecretNames(): string[] {\n  return [\n    'API_KEY',\n    'API_SECRET',\n    'SECRET_KEY',\n    'PRIVATE_KEY',\n    'DATABASE_PASSWORD',\n    'DB_PASSWORD',\n    'JWT_SECRET',\n    'SESSION_SECRET',\n    'AUTH_SECRET',\n    'ENCRYPTION_KEY',\n    'AWS_SECRET_ACCESS_KEY',\n    'STRIPE_SECRET_KEY',\n    'GITHUB_TOKEN',\n  ];\n}\n\n/**\n * Check if a variable should be treated as a secret\n */\nexport function isSecretVariable(name: string, value?: string): boolean {\n  // Check name patterns\n  const nameMatch = findSecretNamePattern(name);\n  if (nameMatch) return true;\n\n  // Check value patterns if provided\n  if (value) {\n    const valueMatch = findSecretValuePattern(value);\n    if (valueMatch) return true;\n  }\n\n  return false;\n}\n\n/**\n * Get security recommendations for a project\n */\nexport function getSecurityRecommendations(issues: Issue[]): string[] {\n  const recommendations: string[] = [];\n\n  const secretIssues = issues.filter((i) => i.type === 'secret-exposed');\n\n  if (secretIssues.length > 0) {\n    recommendations.push('Add .env files to .gitignore to prevent committing secrets');\n    recommendations.push('Consider using a secrets manager like AWS Secrets Manager, HashiCorp Vault, or Doppler');\n    recommendations.push('Use .env.example with placeholder values for documentation');\n    recommendations.push('Enable git pre-commit hooks to scan for secrets before committing');\n  }\n\n  // Check for specific providers\n  const providers = new Set(\n    secretIssues.map((i) => (i.context as { provider?: string })?.provider).filter(Boolean)\n  );\n\n  if (providers.has('AWS')) {\n    recommendations.push('Consider using AWS IAM roles instead of access keys where possible');\n  }\n\n  if (providers.has('Stripe')) {\n    recommendations.push('Use Stripe restricted API keys with minimal permissions in production');\n  }\n\n  return recommendations;\n}\n\n","import pc from 'picocolors';\nimport type { AnalysisResult, Issue, IssueType, Severity } from '../types/index.js';\n\nconst SEVERITY_ICONS: Record<Severity, string> = {\n  error: pc.red('✗'),\n  warning: pc.yellow('⚠'),\n  info: pc.blue('ℹ'),\n};\n\nconst SEVERITY_COLORS: Record<Severity, (text: string) => string> = {\n  error: pc.red,\n  warning: pc.yellow,\n  info: pc.blue,\n};\n\nconst ISSUE_TYPE_LABELS: Record<IssueType, string> = {\n  missing: 'Missing Variables',\n  unused: 'Unused Variables',\n  'type-mismatch': 'Type Mismatches',\n  'sync-drift': 'Sync Drift',\n  'secret-exposed': 'Exposed Secrets',\n  'invalid-value': 'Invalid Values',\n  'dynamic-access': 'Dynamic Access',\n};\n\nexport interface ConsoleReporterOptions {\n  /** Show verbose output */\n  verbose?: boolean;\n  /** Show colors (default: true) */\n  colors?: boolean;\n  /** Maximum issues to show per category */\n  maxIssuesPerCategory?: number;\n}\n\n/**\n * Report analysis results to the console\n */\nexport function reportToConsole(\n  result: AnalysisResult,\n  options: ConsoleReporterOptions = {}\n): void {\n  const { verbose = false, maxIssuesPerCategory = 10 } = options;\n\n  // Print header\n  console.log();\n  console.log(pc.bold(pc.cyan('env-doctor')) + pc.gray(' v1.0.0'));\n  console.log();\n\n  // Group issues by type\n  const issuesByType = groupIssuesByType(result.issues);\n\n  // Print framework info\n  console.log(pc.gray(`Framework: ${result.framework}`));\n  console.log(\n    pc.gray(\n      `Scanned ${result.stats.filesScanned} files, ${result.definedVariables.length} env variables`\n    )\n  );\n  console.log();\n\n  // Print issues by category\n  let hasIssues = false;\n\n  for (const [type, issues] of Object.entries(issuesByType)) {\n    if (issues.length === 0) continue;\n    hasIssues = true;\n\n    const label = ISSUE_TYPE_LABELS[type as IssueType] || type;\n    const severity = issues[0].severity;\n    const icon = SEVERITY_ICONS[severity];\n    const color = SEVERITY_COLORS[severity];\n\n    console.log(color(pc.bold(`${icon} ${label} (${issues.length} ${issues.length === 1 ? 'issue' : 'issues'})`)));\n    console.log();\n\n    const displayIssues = issues.slice(0, maxIssuesPerCategory);\n    for (const issue of displayIssues) {\n      printIssue(issue, verbose);\n    }\n\n    if (issues.length > maxIssuesPerCategory) {\n      console.log(\n        pc.gray(`  ... and ${issues.length - maxIssuesPerCategory} more`)\n      );\n    }\n\n    console.log();\n  }\n\n  // Print sync status if no sync issues\n  if (!issuesByType['sync-drift']?.length && result.templateVariables) {\n    console.log(pc.green('✓ ') + pc.bold('Sync Check'));\n    console.log(pc.gray('  .env and template are in sync'));\n    console.log();\n  }\n\n  // Print summary\n  printSummary(result);\n\n  // Print recommendations if there are critical issues\n  if (result.stats.errorCount > 0) {\n    console.log();\n    console.log(pc.bold('Recommendations:'));\n    console.log(pc.gray('  Run `env-doctor fix` to interactively resolve issues'));\n    console.log(pc.gray('  Run `env-doctor init` to generate a .env.example file'));\n  }\n\n  if (!hasIssues) {\n    console.log(pc.green(pc.bold('✓ No issues found!')));\n    console.log();\n  }\n}\n\n/**\n * Print a single issue\n */\nfunction printIssue(issue: Issue, verbose: boolean): void {\n  const { variable, message, location, fix } = issue;\n\n  // Variable name\n  console.log(`  ${pc.bold(variable)}`);\n\n  // Message\n  console.log(`    ${pc.gray(message)}`);\n\n  // Location\n  if (location) {\n    const loc = location.column\n      ? `${location.file}:${location.line}:${location.column}`\n      : `${location.file}:${location.line}`;\n    console.log(`    ${pc.dim('at')} ${pc.cyan(loc)}`);\n  }\n\n  // Fix suggestion\n  if (fix && verbose) {\n    console.log(`    ${pc.green('fix:')} ${fix}`);\n  }\n\n  console.log();\n}\n\n/**\n * Print summary\n */\nfunction printSummary(result: AnalysisResult): void {\n  const { errorCount, warningCount, infoCount, duration } = result.stats;\n\n  console.log(pc.gray('─'.repeat(50)));\n  console.log();\n\n  const parts: string[] = [];\n\n  if (errorCount > 0) {\n    parts.push(pc.red(`${errorCount} ${errorCount === 1 ? 'error' : 'errors'}`));\n  }\n  if (warningCount > 0) {\n    parts.push(pc.yellow(`${warningCount} ${warningCount === 1 ? 'warning' : 'warnings'}`));\n  }\n  if (infoCount > 0) {\n    parts.push(pc.blue(`${infoCount} info`));\n  }\n\n  if (parts.length > 0) {\n    console.log(`Summary: ${parts.join(', ')}`);\n  } else {\n    console.log(pc.green('Summary: All checks passed!'));\n  }\n\n  console.log(pc.gray(`Completed in ${duration}ms`));\n  console.log();\n}\n\n/**\n * Group issues by type\n */\nfunction groupIssuesByType(issues: Issue[]): Record<string, Issue[]> {\n  const groups: Record<string, Issue[]> = {};\n\n  // Initialize all types to maintain order\n  for (const type of Object.keys(ISSUE_TYPE_LABELS)) {\n    groups[type] = [];\n  }\n\n  for (const issue of issues) {\n    if (!groups[issue.type]) {\n      groups[issue.type] = [];\n    }\n    groups[issue.type].push(issue);\n  }\n\n  return groups;\n}\n\n/**\n * Format for CI output (minimal, good for logs)\n */\nexport function reportForCI(result: AnalysisResult): void {\n  for (const issue of result.issues) {\n    const level = issue.severity === 'error' ? 'error' : issue.severity === 'warning' ? 'warning' : 'notice';\n    const location = issue.location\n      ? `${issue.location.file}:${issue.location.line}`\n      : '';\n\n    // GitHub Actions annotation format\n    if (process.env.GITHUB_ACTIONS) {\n      console.log(`::${level} file=${location}::${issue.message}`);\n    } else {\n      console.log(`[${level.toUpperCase()}] ${location ? location + ': ' : ''}${issue.message}`);\n    }\n  }\n\n  // Exit summary\n  const { errorCount, warningCount } = result.stats;\n  if (errorCount > 0) {\n    console.log(`\\nFound ${errorCount} error(s) and ${warningCount} warning(s)`);\n  }\n}\n\n/**\n * Create a spinner for progress indication\n */\nexport function createSpinner(text: string): {\n  start: () => void;\n  stop: (success?: boolean) => void;\n  update: (newText: string) => void;\n} {\n  const frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];\n  let frameIndex = 0;\n  let intervalId: NodeJS.Timeout | null = null;\n  let currentText = text;\n  const isTTY = process.stdout.isTTY;\n\n  return {\n    start() {\n      if (isTTY) {\n        process.stdout.write(`${pc.cyan(frames[frameIndex])} ${currentText}`);\n        intervalId = setInterval(() => {\n          frameIndex = (frameIndex + 1) % frames.length;\n          process.stdout.clearLine?.(0);\n          process.stdout.cursorTo?.(0);\n          process.stdout.write(`${pc.cyan(frames[frameIndex])} ${currentText}`);\n        }, 80);\n      } else {\n        console.log(`${pc.cyan('...')} ${currentText}`);\n      }\n    },\n    stop(success = true) {\n      if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n      }\n      const icon = success ? pc.green('✓') : pc.red('✗');\n      if (isTTY) {\n        process.stdout.clearLine?.(0);\n        process.stdout.cursorTo?.(0);\n      }\n      console.log(`${icon} ${currentText}`);\n    },\n    update(newText: string) {\n      currentText = newText;\n    },\n  };\n}\n\n","import type { AnalysisResult, Issue } from '../types/index.js';\n\nexport interface JSONReport {\n  /** Tool version */\n  version: string;\n  /** Timestamp of the report */\n  timestamp: string;\n  /** Detected framework */\n  framework: string;\n  /** Summary statistics */\n  summary: {\n    totalIssues: number;\n    errors: number;\n    warnings: number;\n    info: number;\n    filesScanned: number;\n    envFilesParsed: number;\n    duration: number;\n  };\n  /** All issues */\n  issues: JSONIssue[];\n  /** Environment variables defined */\n  variables: {\n    defined: Array<{\n      name: string;\n      file: string;\n      line: number;\n      hasValue: boolean;\n      isSecret: boolean;\n    }>;\n    used: Array<{\n      name: string;\n      file: string;\n      line: number;\n      accessPattern: string;\n      isClientSide: boolean;\n    }>;\n  };\n}\n\nexport interface JSONIssue {\n  type: string;\n  severity: string;\n  variable: string;\n  message: string;\n  location?: {\n    file: string;\n    line: number;\n    column?: number;\n  };\n  fix?: string;\n  context?: Record<string, unknown>;\n}\n\n/**\n * Convert analysis result to JSON report format\n */\nexport function toJSONReport(result: AnalysisResult): JSONReport {\n  return {\n    version: '1.0.0',\n    timestamp: new Date().toISOString(),\n    framework: result.framework,\n    summary: {\n      totalIssues: result.issues.length,\n      errors: result.stats.errorCount,\n      warnings: result.stats.warningCount,\n      info: result.stats.infoCount,\n      filesScanned: result.stats.filesScanned,\n      envFilesParsed: result.stats.envFilesParsed,\n      duration: result.stats.duration,\n    },\n    issues: result.issues.map(issueToJSON),\n    variables: {\n      defined: result.definedVariables.map((v) => ({\n        name: v.name,\n        file: v.file,\n        line: v.line,\n        hasValue: Boolean(v.value),\n        isSecret: v.isSecret ?? false,\n      })),\n      used: result.usedVariables.map((u) => ({\n        name: u.name,\n        file: u.file,\n        line: u.line,\n        accessPattern: u.accessPattern,\n        isClientSide: u.isClientSide ?? false,\n      })),\n    },\n  };\n}\n\n/**\n * Convert a single issue to JSON format\n */\nfunction issueToJSON(issue: Issue): JSONIssue {\n  return {\n    type: issue.type,\n    severity: issue.severity,\n    variable: issue.variable,\n    message: issue.message,\n    location: issue.location,\n    fix: issue.fix,\n    context: issue.context,\n  };\n}\n\n/**\n * Report analysis results as JSON\n */\nexport function reportToJSON(result: AnalysisResult): string {\n  const report = toJSONReport(result);\n  return JSON.stringify(report, null, 2);\n}\n\n/**\n * Report analysis results as JSON (compact, for piping)\n */\nexport function reportToJSONCompact(result: AnalysisResult): string {\n  const report = toJSONReport(result);\n  return JSON.stringify(report);\n}\n\n/**\n * Create a minimal issues-only JSON report\n */\nexport function reportIssuesOnly(issues: Issue[]): string {\n  return JSON.stringify(\n    {\n      count: issues.length,\n      issues: issues.map(issueToJSON),\n    },\n    null,\n    2\n  );\n}\n\n/**\n * Parse JSON report from string\n */\nexport function parseJSONReport(json: string): JSONReport | null {\n  try {\n    return JSON.parse(json) as JSONReport;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Merge multiple JSON reports\n */\nexport function mergeJSONReports(reports: JSONReport[]): JSONReport {\n  if (reports.length === 0) {\n    throw new Error('No reports to merge');\n  }\n\n  const merged: JSONReport = {\n    version: reports[0].version,\n    timestamp: new Date().toISOString(),\n    framework: reports[0].framework,\n    summary: {\n      totalIssues: 0,\n      errors: 0,\n      warnings: 0,\n      info: 0,\n      filesScanned: 0,\n      envFilesParsed: 0,\n      duration: 0,\n    },\n    issues: [],\n    variables: {\n      defined: [],\n      used: [],\n    },\n  };\n\n  const seenIssues = new Set<string>();\n  const seenDefinedVars = new Set<string>();\n  const seenUsedVars = new Set<string>();\n\n  for (const report of reports) {\n    // Merge summaries\n    merged.summary.totalIssues += report.summary.totalIssues;\n    merged.summary.errors += report.summary.errors;\n    merged.summary.warnings += report.summary.warnings;\n    merged.summary.info += report.summary.info;\n    merged.summary.filesScanned += report.summary.filesScanned;\n    merged.summary.envFilesParsed += report.summary.envFilesParsed;\n    merged.summary.duration = Math.max(merged.summary.duration, report.summary.duration);\n\n    // Merge issues (deduplicate)\n    for (const issue of report.issues) {\n      const key = `${issue.type}:${issue.variable}:${issue.location?.file}:${issue.location?.line}`;\n      if (!seenIssues.has(key)) {\n        seenIssues.add(key);\n        merged.issues.push(issue);\n      }\n    }\n\n    // Merge variables (deduplicate)\n    for (const v of report.variables.defined) {\n      const key = `${v.name}:${v.file}`;\n      if (!seenDefinedVars.has(key)) {\n        seenDefinedVars.add(key);\n        merged.variables.defined.push(v);\n      }\n    }\n\n    for (const v of report.variables.used) {\n      const key = `${v.name}:${v.file}:${v.line}`;\n      if (!seenUsedVars.has(key)) {\n        seenUsedVars.add(key);\n        merged.variables.used.push(v);\n      }\n    }\n  }\n\n  return merged;\n}\n\n","import type { AnalysisResult, Issue, IssueType, SARIFOutput, SARIFResult, SARIFRule, SARIFRun } from '../types/index.js';\n\nconst TOOL_NAME = 'env-doctor';\nconst TOOL_VERSION = '1.0.0';\nconst TOOL_INFO_URI = 'https://github.com/yourusername/env-doctor';\n\n/**\n * SARIF rule definitions for each issue type\n */\nconst RULE_DEFINITIONS: Record<IssueType, { name: string; shortDescription: string; fullDescription: string }> = {\n  missing: {\n    name: 'MissingEnvVariable',\n    shortDescription: 'Environment variable is used but not defined',\n    fullDescription:\n      'A environment variable is referenced in the code but not defined in any .env file. This could cause runtime errors or unexpected behavior.',\n  },\n  unused: {\n    name: 'UnusedEnvVariable',\n    shortDescription: 'Environment variable is defined but never used',\n    fullDescription:\n      'An environment variable is defined in a .env file but never referenced in the codebase. This could indicate dead configuration or a typo.',\n  },\n  'type-mismatch': {\n    name: 'TypeMismatch',\n    shortDescription: 'Environment variable value type does not match usage',\n    fullDescription:\n      'The value of an environment variable does not match how it is used in the code. For example, using parseInt() on a non-numeric value.',\n  },\n  'sync-drift': {\n    name: 'SyncDrift',\n    shortDescription: 'Environment files are out of sync',\n    fullDescription:\n      'The .env file and .env.example (or other template) have different variables defined. This can cause issues when setting up new environments.',\n  },\n  'secret-exposed': {\n    name: 'SecretExposed',\n    shortDescription: 'Potential secret value detected',\n    fullDescription:\n      'A variable that appears to contain a secret (API key, password, token) has a value that looks like a real credential. Secrets should not be committed to version control.',\n  },\n  'invalid-value': {\n    name: 'InvalidValue',\n    shortDescription: 'Environment variable has an invalid value',\n    fullDescription:\n      'The value of an environment variable does not match the expected format or constraints defined in the configuration.',\n  },\n  'dynamic-access': {\n    name: 'DynamicAccess',\n    shortDescription: 'Dynamic environment variable access detected',\n    fullDescription:\n      'Environment variables are being accessed dynamically, which makes it difficult to statically analyze which variables are used.',\n  },\n};\n\n/**\n * Convert severity to SARIF level\n */\nfunction severityToLevel(severity: string): 'error' | 'warning' | 'note' {\n  switch (severity) {\n    case 'error':\n      return 'error';\n    case 'warning':\n      return 'warning';\n    default:\n      return 'note';\n  }\n}\n\n/**\n * Get the default level for a rule\n */\nfunction getDefaultLevel(type: IssueType): 'error' | 'warning' | 'note' {\n  switch (type) {\n    case 'missing':\n    case 'secret-exposed':\n    case 'invalid-value':\n      return 'error';\n    case 'unused':\n    case 'type-mismatch':\n    case 'sync-drift':\n      return 'warning';\n    case 'dynamic-access':\n      return 'note';\n    default:\n      return 'warning';\n  }\n}\n\n/**\n * Create SARIF rules from issue types\n */\nfunction createRules(issues: Issue[]): SARIFRule[] {\n  const usedTypes = new Set(issues.map((i) => i.type));\n  const rules: SARIFRule[] = [];\n\n  for (const type of usedTypes) {\n    const def = RULE_DEFINITIONS[type];\n    if (def) {\n      rules.push({\n        id: `env-doctor/${type}`,\n        name: def.name,\n        shortDescription: { text: def.shortDescription },\n        fullDescription: { text: def.fullDescription },\n        defaultConfiguration: { level: getDefaultLevel(type) },\n        helpUri: `${TOOL_INFO_URI}#${type}`,\n      });\n    }\n  }\n\n  return rules;\n}\n\n/**\n * Convert an issue to a SARIF result\n */\nfunction issueToResult(issue: Issue): SARIFResult {\n  const location = issue.location || { file: '.env', line: 1 };\n\n  return {\n    ruleId: `env-doctor/${issue.type}`,\n    level: severityToLevel(issue.severity),\n    message: { text: issue.message },\n    locations: [\n      {\n        physicalLocation: {\n          artifactLocation: { uri: location.file },\n          region: {\n            startLine: location.line,\n            startColumn: location.column,\n          },\n        },\n      },\n    ],\n  };\n}\n\n/**\n * Convert analysis results to SARIF format\n */\nexport function toSARIF(result: AnalysisResult): SARIFOutput {\n  const run: SARIFRun = {\n    tool: {\n      driver: {\n        name: TOOL_NAME,\n        version: TOOL_VERSION,\n        informationUri: TOOL_INFO_URI,\n        rules: createRules(result.issues),\n      },\n    },\n    results: result.issues.map(issueToResult),\n  };\n\n  return {\n    $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',\n    version: '2.1.0',\n    runs: [run],\n  };\n}\n\n/**\n * Report analysis results as SARIF JSON string\n */\nexport function reportToSARIF(result: AnalysisResult): string {\n  const sarif = toSARIF(result);\n  return JSON.stringify(sarif, null, 2);\n}\n\n/**\n * Create a minimal SARIF report for specific issues\n */\nexport function createMinimalSARIF(issues: Issue[]): SARIFOutput {\n  const run: SARIFRun = {\n    tool: {\n      driver: {\n        name: TOOL_NAME,\n        version: TOOL_VERSION,\n        informationUri: TOOL_INFO_URI,\n        rules: createRules(issues),\n      },\n    },\n    results: issues.map(issueToResult),\n  };\n\n  return {\n    $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',\n    version: '2.1.0',\n    runs: [run],\n  };\n}\n\n/**\n * Merge multiple SARIF reports\n */\nexport function mergeSARIF(reports: SARIFOutput[]): SARIFOutput {\n  if (reports.length === 0) {\n    throw new Error('No reports to merge');\n  }\n\n  // Combine all runs\n  const allRuns: SARIFRun[] = [];\n\n  for (const report of reports) {\n    allRuns.push(...report.runs);\n  }\n\n  return {\n    $schema: reports[0].$schema,\n    version: reports[0].version,\n    runs: allRuns,\n  };\n}\n\n/**\n * Validate SARIF structure (basic validation)\n */\nexport function validateSARIF(sarif: unknown): sarif is SARIFOutput {\n  if (!sarif || typeof sarif !== 'object') return false;\n\n  const s = sarif as Record<string, unknown>;\n\n  if (typeof s.$schema !== 'string') return false;\n  if (typeof s.version !== 'string') return false;\n  if (!Array.isArray(s.runs)) return false;\n\n  return true;\n}\n\n","import simpleGit, { SimpleGit } from 'simple-git';\nimport type { GitScanResult } from '../types/index.js';\nimport { logger } from '../utils/logger.js';\n\n/**\n * Patterns that indicate a secret value in git history\n */\nconst SECRET_VALUE_PATTERNS = [\n  // API Keys\n  /^sk[-_]live[-_][a-zA-Z0-9]{24,}/,\n  /^sk[-_]test[-_][a-zA-Z0-9]{24,}/,\n  /^pk[-_]live[-_][a-zA-Z0-9]{24,}/,\n  /^pk[-_]test[-_][a-zA-Z0-9]{24,}/,\n  // AWS\n  /^AKIA[A-Z0-9]{16}/,\n  /^[a-zA-Z0-9/+=]{40}/, // AWS secret key pattern\n  // GitHub\n  /^ghp_[a-zA-Z0-9]{36}/,\n  /^gho_[a-zA-Z0-9]{36}/,\n  /^github_pat_[a-zA-Z0-9_]{22,}/,\n  // JWT\n  /^eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*/,\n  // Generic secrets (long alphanumeric strings)\n  /^[a-zA-Z0-9]{32,}/,\n  // Database URLs with credentials\n  /^(postgres|mysql|mongodb):\\/\\/[^:]+:[^@]+@/,\n  // Private keys\n  /-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----/,\n];\n\n/**\n * Variable names that typically contain secrets\n */\nconst SECRET_VAR_NAMES = [\n  /password/i,\n  /secret/i,\n  /api[_-]?key/i,\n  /private[_-]?key/i,\n  /access[_-]?token/i,\n  /auth[_-]?token/i,\n  /credentials?/i,\n  /^AWS_SECRET/i,\n  /^DATABASE_URL$/,\n  /^REDIS_URL$/,\n];\n\nexport interface GitScanOptions {\n  /** Root directory of the git repository */\n  rootDir: string;\n  /** How many commits back to scan */\n  depth?: number;\n  /** Specific files to scan (glob patterns) */\n  files?: string[];\n  /** Include only specific branches */\n  branches?: string[];\n}\n\n/**\n * Scan git history for leaked secrets\n */\nexport async function scanGitHistory(options: GitScanOptions): Promise<{\n  results: GitScanResult[];\n  error?: string;\n}> {\n  const { rootDir, depth = 100, files } = options;\n  const results: GitScanResult[] = [];\n\n  let git: SimpleGit;\n  try {\n    git = simpleGit(rootDir);\n\n    // Check if this is a git repository\n    const isRepo = await git.checkIsRepo();\n    if (!isRepo) {\n      return { results: [], error: 'Not a git repository' };\n    }\n  } catch (err) {\n    const message = err instanceof Error ? err.message : 'Unknown error';\n    return { results: [], error: `Failed to initialize git: ${message}` };\n  }\n\n  try {\n    // Get commit history\n    const logOptions = [\n      `-${depth}`,\n      '--all',\n      '--format=%H|%an|%ai',\n      '-p', // Show patches\n    ];\n\n    if (files && files.length > 0) {\n      logOptions.push('--', ...files);\n    }\n\n    const log = await git.raw(logOptions);\n\n    // Parse the log output\n    const commits = parseGitLog(log);\n\n    for (const commit of commits) {\n      // Look for env-like patterns in the diff\n      const secrets = findSecretsInDiff(commit.diff);\n\n      for (const secret of secrets) {\n        results.push({\n          commit: commit.hash,\n          author: commit.author,\n          date: commit.date,\n          file: secret.file,\n          line: secret.line,\n          variable: secret.variable,\n          redactedValue: redactValue(secret.value),\n        });\n      }\n    }\n\n    logger.debug(`Scanned ${commits.length} commits, found ${results.length} potential secrets`);\n  } catch (err) {\n    const message = err instanceof Error ? err.message : 'Unknown error';\n    return { results, error: `Git scan error: ${message}` };\n  }\n\n  return { results };\n}\n\ninterface ParsedCommit {\n  hash: string;\n  author: string;\n  date: string;\n  diff: string;\n}\n\n/**\n * Parse git log output\n */\nfunction parseGitLog(log: string): ParsedCommit[] {\n  const commits: ParsedCommit[] = [];\n  const commitRegex = /^([a-f0-9]{40})\\|([^|]*)\\|([^|]*)\\n([\\s\\S]*?)(?=\\n[a-f0-9]{40}\\||\\n*$)/gm;\n\n  let match;\n  while ((match = commitRegex.exec(log)) !== null) {\n    commits.push({\n      hash: match[1],\n      author: match[2],\n      date: match[3],\n      diff: match[4],\n    });\n  }\n\n  // If regex didn't work, try line-by-line parsing\n  if (commits.length === 0) {\n    const lines = log.split('\\n');\n    let currentCommit: ParsedCommit | null = null;\n    let diffLines: string[] = [];\n\n    for (const line of lines) {\n      const headerMatch = line.match(/^([a-f0-9]{40})\\|([^|]*)\\|(.*)$/);\n      if (headerMatch) {\n        if (currentCommit) {\n          currentCommit.diff = diffLines.join('\\n');\n          commits.push(currentCommit);\n        }\n        currentCommit = {\n          hash: headerMatch[1],\n          author: headerMatch[2],\n          date: headerMatch[3],\n          diff: '',\n        };\n        diffLines = [];\n      } else if (currentCommit) {\n        diffLines.push(line);\n      }\n    }\n\n    if (currentCommit) {\n      currentCommit.diff = diffLines.join('\\n');\n      commits.push(currentCommit);\n    }\n  }\n\n  return commits;\n}\n\ninterface SecretMatch {\n  file: string;\n  line: number;\n  variable: string;\n  value: string;\n}\n\n/**\n * Find secrets in a git diff\n */\nfunction findSecretsInDiff(diff: string): SecretMatch[] {\n  const secrets: SecretMatch[] = [];\n  const lines = diff.split('\\n');\n\n  let currentFile = '';\n  let lineNumber = 0;\n\n  for (const line of lines) {\n    // Track file changes\n    const fileMatch = line.match(/^\\+\\+\\+ b\\/(.+)$/);\n    if (fileMatch) {\n      currentFile = fileMatch[1];\n      lineNumber = 0;\n      continue;\n    }\n\n    // Track line numbers\n    const hunkMatch = line.match(/^@@ -\\d+(?:,\\d+)? \\+(\\d+)/);\n    if (hunkMatch) {\n      lineNumber = parseInt(hunkMatch[1], 10) - 1;\n      continue;\n    }\n\n    // Only check added lines in env-like files\n    if (line.startsWith('+') && !line.startsWith('+++')) {\n      lineNumber++;\n\n      // Check if this is an env file or contains env-like patterns\n      if (isEnvFile(currentFile) || containsEnvPattern(line)) {\n        const envMatch = line.match(/^\\+\\s*([A-Z_][A-Z0-9_]*)=(.+)$/);\n        if (envMatch) {\n          const [, variable, value] = envMatch;\n\n          // Check if this looks like a secret\n          if (isLikelySecret(variable, value)) {\n            secrets.push({\n              file: currentFile,\n              line: lineNumber,\n              variable,\n              value,\n            });\n          }\n        }\n      }\n    } else if (!line.startsWith('-')) {\n      lineNumber++;\n    }\n  }\n\n  return secrets;\n}\n\n/**\n * Check if a file is an env file\n */\nfunction isEnvFile(filename: string): boolean {\n  const envPatterns = [/^\\.env/, /\\.env$/, /\\.env\\./];\n  return envPatterns.some((pattern) => pattern.test(filename));\n}\n\n/**\n * Check if a line contains env-like patterns\n */\nfunction containsEnvPattern(line: string): boolean {\n  return /[A-Z_][A-Z0-9_]*=.+/.test(line);\n}\n\n/**\n * Check if a variable/value pair looks like a secret\n */\nfunction isLikelySecret(variable: string, value: string): boolean {\n  // Check variable name\n  for (const pattern of SECRET_VAR_NAMES) {\n    if (pattern.test(variable)) {\n      return true;\n    }\n  }\n\n  // Check value patterns\n  for (const pattern of SECRET_VALUE_PATTERNS) {\n    if (pattern.test(value)) {\n      return true;\n    }\n  }\n\n  // Check for high entropy (likely random strings)\n  if (value.length > 20 && hasHighEntropy(value)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Simple entropy check for detecting random strings\n */\nfunction hasHighEntropy(str: string): boolean {\n  const charCounts: Record<string, number> = {};\n  for (const char of str) {\n    charCounts[char] = (charCounts[char] || 0) + 1;\n  }\n\n  const uniqueChars = Object.keys(charCounts).length;\n  const ratio = uniqueChars / str.length;\n\n  // High ratio of unique characters suggests randomness\n  return ratio > 0.4 && uniqueChars > 10;\n}\n\n/**\n * Redact a secret value for display\n */\nfunction redactValue(value: string): string {\n  if (value.length <= 8) {\n    return '****';\n  }\n\n  const visibleStart = value.slice(0, 4);\n  const visibleEnd = value.slice(-4);\n  return `${visibleStart}...${visibleEnd}`;\n}\n\n/**\n * Check if the current directory is a git repository\n */\nexport async function isGitRepository(rootDir: string): Promise<boolean> {\n  try {\n    const git = simpleGit(rootDir);\n    return await git.checkIsRepo();\n  } catch {\n    return false;\n  }\n}\n\n"],"mappings":";;;;;;;AACA,OAAO,UAAU;AACjB,SAAS,qBAAqB;AAF9B;AAAA;AAAA;AAAA;AAAA;;;ACAA,SAAS,SAAS;AAAlB,IA6Da,oBAaA,uBAgBA;AA1Fb;AAAA;AAAA;AAAA;AA6DO,IAAM,qBAAqB,EAAE,OAAO;AAAA,MACzC,UAAU,EAAE,QAAQ,EAAE,SAAS;AAAA,MAC/B,QAAQ,EAAE,QAAQ,EAAE,SAAS;AAAA,MAC7B,MAAM,EAAE,KAAK,CAAC,UAAU,UAAU,WAAW,QAAQ,OAAO,OAAO,CAAC,EAAE,SAAS;AAAA,MAC/E,SAAS,EAAE,WAAW,MAAM,EAAE,SAAS;AAAA,MACvC,SAAS,EAAE,MAAM,CAAC,EAAE,OAAO,GAAG,EAAE,OAAO,GAAG,EAAE,QAAQ,CAAC,CAAC,EAAE,SAAS;AAAA,MACjE,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,MACnC,aAAa,EAAE,OAAO,EAAE,SAAS;AAAA,IACnC,CAAC;AAKM,IAAM,wBAAwB,EAAE,OAAO;AAAA,MAC5C,UAAU,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC;AAAA,MAC9C,cAAc,EAAE,OAAO,EAAE,SAAS;AAAA,MAClC,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,QAAQ,CAAC,0BAA0B,CAAC;AAAA,MACjE,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,QAAQ,CAAC,gBAAgB,QAAQ,eAAe,aAAa,CAAC;AAAA,MAC3F,WAAW,EAAE,KAAK,CAAC,QAAQ,UAAU,QAAQ,OAAO,MAAM,CAAC,EAAE,QAAQ,MAAM;AAAA,MAC3E,WAAW,EAAE,OAAO,EAAE,OAAO,GAAG,kBAAkB,EAAE,QAAQ,CAAC,CAAC;AAAA,MAC9D,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,QAAQ,CAAC,CAAC;AAAA,MACtC,QAAQ,EAAE,QAAQ,EAAE,SAAS;AAAA,MAC7B,gBAAgB,EAAE,MAAM,EAAE,WAAW,MAAM,CAAC,EAAE,SAAS;AAAA,MACvD,MAAM,EAAE,OAAO,EAAE,SAAS;AAAA,IAC5B,CAAC;AAKM,IAAM,gBAAiC;AAAA,MAC5C,UAAU,CAAC,MAAM;AAAA,MACjB,SAAS,CAAC,4BAA4B,4BAA4B,4BAA4B;AAAA,MAC9F,SAAS,CAAC,gBAAgB,QAAQ,SAAS,SAAS,eAAe,eAAe,iBAAiB;AAAA,MACnG,WAAW;AAAA,MACX,WAAW,CAAC;AAAA,MACZ,QAAQ,CAAC;AAAA,MACT,QAAQ;AAAA,IACV;AAAA;AAAA;;;AClGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;;ACFA,SAAS,UAAU,QAAQ,YAAY;AACvC,SAAS,iBAAiB;AAC1B,SAAS,SAAS,UAAU,eAAe;AAK3C,eAAsB,WAAWA,OAAgC;AAC/D,MAAI;AACF,UAAM,OAAOA,OAAM,UAAU,IAAI;AACjC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AA4BA,eAAsB,aAA0BA,OAAiC;AAC/E,MAAI;AACF,UAAM,UAAU,MAAM,SAASA,OAAM,OAAO;AAC5C,WAAO,KAAK,MAAM,OAAO;AAAA,EAC3B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AA0BA,eAAsB,OAAO,UAAkB,UAA0C;AACvF,MAAI,aAAa,QAAQ,QAAQ;AACjC,QAAM,OAAO,QAAQ,GAAG;AAExB,SAAO,eAAe,MAAM;AAC1B,UAAM,WAAW,QAAQ,YAAY,QAAQ;AAC7C,QAAI,MAAM,WAAW,QAAQ,GAAG;AAC9B,aAAO;AAAA,IACT;AACA,iBAAa,QAAQ,UAAU;AAAA,EACjC;AAEA,SAAO;AACT;AAxFA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,OAAO,QAAQ;AAAf,IAIM,YAQA,QAgFO;AA5Fb;AAAA;AAAA;AAAA;AAIA,IAAM,aAAuC;AAAA,MAC3C,OAAO;AAAA,MACP,MAAM;AAAA,MACN,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,IACV;AAEA,IAAM,SAAN,MAAa;AAAA,MACH,QAAkB;AAAA,MAClB,UAAU;AAAA,MAElB,SAAS,OAAiB;AACxB,aAAK,QAAQ;AAAA,MACf;AAAA,MAEA,WAAW,SAAkB;AAC3B,aAAK,UAAU;AACf,YAAI,SAAS;AACX,eAAK,QAAQ;AAAA,QACf;AAAA,MACF;AAAA,MAEQ,UAAU,OAA0B;AAC1C,eAAO,WAAW,KAAK,KAAK,WAAW,KAAK,KAAK;AAAA,MACnD;AAAA,MAEA,SAAS,MAAiB;AACxB,YAAI,KAAK,UAAU,OAAO,GAAG;AAC3B,kBAAQ,IAAI,GAAG,KAAK,SAAS,GAAG,GAAG,IAAI;AAAA,QACzC;AAAA,MACF;AAAA,MAEA,QAAQ,MAAiB;AACvB,YAAI,KAAK,UAAU,MAAM,GAAG;AAC1B,kBAAQ,IAAI,GAAG,IAAI;AAAA,QACrB;AAAA,MACF;AAAA,MAEA,WAAW,MAAiB;AAC1B,YAAI,KAAK,UAAU,MAAM,GAAG;AAC1B,kBAAQ,IAAI,GAAG,MAAM,QAAG,GAAG,GAAG,IAAI;AAAA,QACpC;AAAA,MACF;AAAA,MAEA,QAAQ,MAAiB;AACvB,YAAI,KAAK,UAAU,MAAM,GAAG;AAC1B,kBAAQ,IAAI,GAAG,OAAO,QAAG,GAAG,GAAG,IAAI;AAAA,QACrC;AAAA,MACF;AAAA,MAEA,SAAS,MAAiB;AACxB,YAAI,KAAK,UAAU,OAAO,GAAG;AAC3B,kBAAQ,MAAM,GAAG,IAAI,QAAG,GAAG,GAAG,IAAI;AAAA,QACpC;AAAA,MACF;AAAA;AAAA,MAGA,OAAO,MAAiB;AACtB,YAAI,KAAK,UAAU,MAAM,GAAG;AAC1B,kBAAQ,IAAI,GAAG,IAAI;AAAA,QACrB;AAAA,MACF;AAAA;AAAA,MAGA,QAAQ;AACN,YAAI,KAAK,UAAU,MAAM,GAAG;AAC1B,kBAAQ,IAAI;AAAA,QACd;AAAA,MACF;AAAA;AAAA,MAGA,OAAO,MAAc;AACnB,YAAI,KAAK,UAAU,MAAM,GAAG;AAC1B,kBAAQ,IAAI;AACZ,kBAAQ,IAAI,GAAG,KAAK,GAAG,KAAK,IAAI,CAAC,CAAC;AAClC,kBAAQ,IAAI;AAAA,QACd;AAAA,MACF;AAAA;AAAA,MAGA,UAAU;AACR,YAAI,KAAK,UAAU,MAAM,GAAG;AAC1B,kBAAQ,IAAI,GAAG,KAAK,SAAI,OAAO,EAAE,CAAC,CAAC;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAEO,IAAM,SAAS,IAAI,OAAO;AAAA;AAAA;;;AC5FjC,SAAS,WAAAC,UAAS,WAAAC,gBAAe;AACjC,SAAS,qBAAqB;AAoB9B,eAAsB,WACpB,YACA,UAAkB,QAAQ,IAAI,GAC6B;AAE3D,MAAI,YAAY;AACd,UAAM,eAAeD,SAAQ,SAAS,UAAU;AAChD,QAAI,MAAM,WAAW,YAAY,GAAG;AAClC,YAAM,SAAS,MAAM,eAAe,YAAY;AAChD,aAAO,EAAE,QAAQ,kBAAkB,MAAM,GAAG,YAAY,aAAa;AAAA,IACvE;AACA,WAAO,KAAK,0BAA0B,UAAU,EAAE;AAClD,WAAO,EAAE,QAAQ,EAAE,GAAG,eAAe,MAAM,QAAQ,EAAE;AAAA,EACvD;AAGA,aAAW,YAAY,kBAAkB;AACvC,UAAM,YAAY,MAAM,OAAO,UAAU,OAAO;AAChD,QAAI,WAAW;AACb,aAAO,MAAM,mBAAmB,SAAS,EAAE;AAC3C,YAAM,SAAS,MAAM,eAAe,SAAS;AAC7C,aAAO;AAAA,QACL,QAAQ,kBAAkB,QAAQC,SAAQ,SAAS,CAAC;AAAA,QACpD,YAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAGA,QAAM,kBAAkBD,SAAQ,SAAS,cAAc;AACvD,MAAI,MAAM,WAAW,eAAe,GAAG;AACrC,UAAM,cAAc,MAAM;AAAA,MACxB;AAAA,IACF;AACA,QAAI,cAAc,YAAY,GAAG;AAC/B,aAAO,MAAM,8BAA8B;AAC3C,aAAO;AAAA,QACL,QAAQ,kBAAkB,YAAY,YAAY,GAAG,OAAO;AAAA,QAC5D,YAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAGA,SAAO,MAAM,iCAAiC;AAC9C,SAAO,EAAE,QAAQ,EAAE,GAAG,eAAe,MAAM,QAAQ,EAAE;AACvD;AAKA,eAAe,eAAe,UAAqD;AACjF,QAAM,MAAM,SAAS,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY;AAEnD,MAAI;AACF,QAAI,QAAQ,UAAU,SAAS,SAAS,IAAI,GAAG;AAC7C,YAAM,UAAU,MAAM,aAAuC,QAAQ;AACrE,aAAO,WAAW,CAAC;AAAA,IACrB;AAGA,UAAM,UAAU,cAAc,QAAQ,EAAE;AACxC,UAAM,SAAS,MAAM,OAAO;AAC5B,WAAO,OAAO,WAAW;AAAA,EAC3B,SAAS,KAAK;AACZ,WAAO,KAAK,8BAA8B,QAAQ,KAAK,eAAe,QAAQ,IAAI,UAAU,eAAe,EAAE;AAC7G,WAAO,CAAC;AAAA,EACV;AACF;AAKA,SAAS,kBACP,YACA,SACiB;AACjB,QAAM,SAAS;AAAA,IACb,GAAG;AAAA,IACH,GAAG;AAAA,IACH,MAAM,WAAW,QAAQ,WAAW,QAAQ,IAAI;AAAA,IAChD,WAAW;AAAA,MACT,GAAG,cAAc;AAAA,MACjB,GAAG,WAAW;AAAA,IAChB;AAAA,EACF;AAGA,QAAM,SAAS,sBAAsB,UAAU,MAAM;AACrD,MAAI,CAAC,OAAO,SAAS;AACnB,WAAO,KAAK,6BAA6B;AACzC,eAAW,SAAS,OAAO,MAAM,QAAQ;AACvC,aAAO,KAAK,KAAK,MAAM,KAAK,KAAK,GAAG,CAAC,KAAK,MAAM,OAAO,EAAE;AAAA,IAC3D;AAAA,EACF;AAEA,SAAO;AACT;AAKO,SAAS,yBAAiC;AAC/C,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4CT;AAKO,SAAS,qBACd,YACA,KACiB;AAEjB,QAAM,aAAuC;AAAA,IAC3C,aAAa,CAAC,QAAQ,cAAc,oBAAoB,wBAAwB;AAAA,IAChF,YAAY,CAAC,QAAQ,mBAAmB,uBAAuB;AAAA,IAC/D,MAAM,CAAC,QAAQ,aAAa,iBAAiB;AAAA,IAC7C,SAAS,CAAC,QAAQ,gBAAgB,oBAAoB;AAAA,EACxD;AAEA,QAAM,WAAW,WAAW,GAAG,KAAK,CAAC,QAAQ,GAAG,EAAE;AAElD,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,EACF;AACF;AA/LA,IAMM;AANN,IAAAE,eAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA,IAAM,mBAAmB;AAAA,MACvB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA;AAAA;;;AChBA;AAMAC;AAJA,SAAS,eAAe;AACxB,OAAOC,SAAQ;AACf,SAAS,WAAAC,gBAAe;AACxB,SAAS,iBAAiB;;;ACL1B;;;ACAA;AAGA;AACA;AAJA,SAAS,YAAAC,iBAAgB;AACzB,SAAS,WAAAC,gBAAe;AAQxB,IAAM,kBAAkB;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAKA,IAAM,4BAA4B;AAAA,EAChC;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AACF;AAUA,eAAsB,aACpB,UACA,UAAkB,QAAQ,IAAI,GACR;AACtB,QAAM,eAAeA,SAAQ,SAAS,QAAQ;AAC9C,QAAM,YAA2B,CAAC;AAClC,QAAM,SAAmD,CAAC;AAE1D,MAAI,CAAE,MAAM,WAAW,YAAY,GAAI;AACrC,WAAO,MAAM,uBAAuB,YAAY,EAAE;AAClD,WAAO,EAAE,WAAW,QAAQ,CAAC,EAAE,MAAM,GAAG,SAAS,mBAAmB,QAAQ,GAAG,CAAC,EAAE;AAAA,EACpF;AAEA,MAAI;AACJ,MAAI;AACF,cAAU,MAAMD,UAAS,cAAc,OAAO;AAAA,EAChD,SAAS,KAAK;AACZ,UAAM,UAAU,eAAe,QAAQ,IAAI,UAAU;AACrD,WAAO,EAAE,WAAW,QAAQ,CAAC,EAAE,MAAM,GAAG,SAAS,wBAAwB,OAAO,GAAG,CAAC,EAAE;AAAA,EACxF;AAEA,QAAM,QAAQ,QAAQ,MAAM,IAAI;AAEhC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,aAAa,IAAI;AACvB,UAAM,UAAU,MAAM,CAAC;AACvB,UAAM,OAAO,QAAQ,KAAK;AAG1B,QAAI,CAAC,QAAQ,KAAK,WAAW,GAAG,GAAG;AACjC;AAAA,IACF;AAGA,UAAM,SAAS,UAAU,MAAM,UAAU;AAEzC,QAAI,OAAO,OAAO;AAChB,aAAO,KAAK,EAAE,MAAM,YAAY,SAAS,OAAO,MAAM,CAAC;AACvD;AAAA,IACF;AAEA,QAAI,OAAO,UAAU;AACnB,gBAAU,KAAK;AAAA,QACb,GAAG,OAAO;AAAA,QACV,MAAM;AAAA,QACN,KAAK;AAAA,QACL,UAAU,iBAAiB,OAAO,SAAS,MAAM,OAAO,SAAS,KAAK;AAAA,MACxE,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO,EAAE,WAAW,OAAO;AAC7B;AAUA,SAAS,UAAU,MAAc,YAAqC;AAEpE,MAAI,gBAAgB;AACpB,MAAI,cAAc,WAAW,SAAS,GAAG;AACvC,oBAAgB,cAAc,MAAM,CAAC;AAAA,EACvC;AAGA,QAAM,aAAa,cAAc,QAAQ,GAAG;AAE5C,MAAI,eAAe,IAAI;AAErB,WAAO,EAAE,OAAO,mCAAmC;AAAA,EACrD;AAEA,QAAM,OAAO,cAAc,MAAM,GAAG,UAAU,EAAE,KAAK;AACrD,MAAI,QAAQ,cAAc,MAAM,aAAa,CAAC;AAG9C,MAAI,CAAC,oBAAoB,IAAI,GAAG;AAC9B,WAAO,EAAE,OAAO,2BAA2B,IAAI,IAAI;AAAA,EACrD;AAGA,UAAQ,WAAW,KAAK;AAExB,SAAO;AAAA,IACL,UAAU;AAAA,MACR;AAAA,MACA;AAAA,MACA,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAKA,SAAS,WAAW,OAAuB;AACzC,UAAQ,MAAM,KAAK;AAGnB,MACG,MAAM,WAAW,GAAG,KAAK,MAAM,SAAS,GAAG,KAC3C,MAAM,WAAW,GAAG,KAAK,MAAM,SAAS,GAAG,GAC5C;AACA,UAAM,QAAQ,MAAM,CAAC;AACrB,YAAQ,MAAM,MAAM,GAAG,EAAE;AAGzB,QAAI,UAAU,KAAK;AACjB,cAAQ,MACL,QAAQ,QAAQ,IAAI,EACpB,QAAQ,QAAQ,IAAI,EACpB,QAAQ,QAAQ,GAAI,EACpB,QAAQ,QAAQ,GAAG,EACnB,QAAQ,SAAS,IAAI;AAAA,IAC1B;AAAA,EACF,OAAO;AAEL,UAAM,eAAe,MAAM,QAAQ,IAAI;AACvC,QAAI,iBAAiB,IAAI;AACvB,cAAQ,MAAM,MAAM,GAAG,YAAY,EAAE,KAAK;AAAA,IAC5C;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,oBAAoB,MAAuB;AAElD,SAAO,2BAA2B,KAAK,IAAI;AAC7C;AAKA,SAAS,iBAAiB,MAAc,OAAwB;AAE9D,aAAW,WAAW,iBAAiB;AACrC,QAAI,QAAQ,KAAK,IAAI,GAAG;AACtB,aAAO;AAAA,IACT;AAAA,EACF;AAGA,MAAI,OAAO;AACT,eAAW,WAAW,2BAA2B;AAC/C,UAAI,QAAQ,KAAK,KAAK,GAAG;AACvB,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAKA,eAAsB,cACpB,WACA,UAAkB,QAAQ,IAAI,GACR;AACtB,QAAM,eAA8B,CAAC;AACrC,QAAM,YAAsD,CAAC;AAC7D,QAAM,gBAAgB,oBAAI,IAAyB;AAEnD,aAAW,YAAY,WAAW;AAChC,UAAM,SAAS,MAAM,aAAa,UAAU,OAAO;AAGnD,eAAW,YAAY,OAAO,WAAW;AACvC,oBAAc,IAAI,SAAS,MAAM,QAAQ;AAAA,IAC3C;AAEA,cAAU,KAAK,GAAG,OAAO,MAAM;AAAA,EACjC;AAGA,eAAa,KAAK,GAAG,cAAc,OAAO,CAAC;AAE3C,SAAO,EAAE,WAAW,cAAc,QAAQ,UAAU;AACtD;AAKO,SAAS,eACd,OACgE;AAChE,MAAI,CAAC,MAAO,QAAO;AAGnB,MAAI,UAAU,UAAU,UAAU,SAAS;AACzC,WAAO;AAAA,EACT;AAGA,MAAI,kBAAkB,KAAK,KAAK,GAAG;AACjC,WAAO;AAAA,EACT;AAGA,MAAK,MAAM,WAAW,GAAG,KAAK,MAAM,SAAS,GAAG,KAAO,MAAM,WAAW,GAAG,KAAK,MAAM,SAAS,GAAG,GAAI;AACpG,QAAI;AACF,WAAK,MAAM,KAAK;AAChB,aAAO;AAAA,IACT,QAAQ;AAAA,IAER;AAAA,EACF;AAGA,MAAI,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM,SAAS,GAAG,GAAG;AAC/C,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;ACjRA;AAAA,SAAS,aAAa;AAEtB,SAAS,YAAAE,iBAAgB;AACzB,SAAS,YAAAC,iBAAgB;;;ACHzB;AAAA,SAAS,YAAY;AACrB,SAAS,WAAAC,gBAAe;AAgBxB,eAAsB,UAAU,SAAyC;AACvE,QAAM,EAAE,KAAK,SAAS,SAAS,iBAAiB,MAAM,IAAI;AAE1D,QAAM,QAAQ,MAAM,KAAK,SAAS;AAAA,IAChC;AAAA,IACA,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,OAAO;AAAA,IACP,QAAQ;AAAA,EACV,CAAC;AAED,SAAO,MAAM,IAAI,CAAC,MAAMA,SAAQ,CAAC,CAAC;AACpC;AAuBO,SAAS,qBACd,UACA,gBACA,UACS;AACT,aAAW,WAAW,gBAAgB;AAEpC,QAAI,QAAQ,SAAS,GAAG,GAAG;AACzB,YAAM,CAAC,MAAM,UAAU,IAAI,QAAQ,MAAM,GAAG;AAC5C,UAAI,YAAY,SAAS,UAAU;AACjC,YAAI,uBAAuB,UAAU,UAAU,GAAG;AAChD,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF,OAAO;AAEL,UAAI,uBAAuB,UAAU,OAAO,GAAG;AAC7C,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAKA,SAAS,uBAAuB,UAAkB,SAA0B;AAC1E,MAAI,QAAQ,SAAS,GAAG,GAAG;AACzB,WAAO,SAAS,WAAW,QAAQ,MAAM,GAAG,EAAE,CAAC;AAAA,EACjD;AACA,MAAI,QAAQ,WAAW,GAAG,GAAG;AAC3B,WAAO,SAAS,SAAS,QAAQ,MAAM,CAAC,CAAC;AAAA,EAC3C;AACA,SAAO,aAAa;AACtB;;;ADjFA;AAsBA,IAAM,kBAA4C;AAAA,EAChD,QAAQ,CAAC,cAAc;AAAA,EACvB,MAAM,CAAC,OAAO;AAAA,EACd,KAAK,CAAC,YAAY;AAAA,EAClB,MAAM,CAAC;AACT;AAKA,eAAsB,SAAS,SAAmD;AAChF,QAAM,EAAE,SAAS,SAAS,SAAS,UAAU,IAAI;AAEjD,QAAM,SAAqB,CAAC;AAC5B,QAAM,SAAmD,CAAC;AAG1D,QAAM,QAAQ,MAAM,UAAU;AAAA,IAC5B,KAAK;AAAA,IACL;AAAA,IACA;AAAA,EACF,CAAC;AAED,SAAO,MAAM,SAAS,MAAM,MAAM,gBAAgB;AAElD,aAAW,QAAQ,OAAO;AACxB,QAAI;AACF,YAAM,UAAU,MAAMC,UAAS,MAAM,OAAO;AAC5C,YAAM,aAAa,gBAAgB,SAAS,MAAM,SAAS,SAAS;AACpE,aAAO,KAAK,GAAG,UAAU;AAAA,IAC3B,SAAS,KAAK;AACZ,YAAM,UAAU,eAAe,QAAQ,IAAI,UAAU;AACrD,aAAO,KAAK,EAAE,MAAMC,UAAS,SAAS,IAAI,GAAG,QAAQ,CAAC;AACtD,aAAO,MAAM,kBAAkB,IAAI,KAAK,OAAO,EAAE;AAAA,IACnD;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,cAAc,MAAM;AAAA,EACtB;AACF;AAKO,SAAS,gBACd,SACA,UACA,SACA,WACY;AACZ,QAAM,SAAqB,CAAC;AAC5B,QAAM,eAAeA,UAAS,SAAS,QAAQ;AAG/C,QAAM,eAAe,iBAAiB,QAAQ;AAG9C,QAAM,iBAAiB,gBAAgB,SAAS,KAAK,CAAC;AAEtD,MAAI;AACF,UAAM,MAAM,MAAM,SAAS;AAAA,MACzB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,OAAO;AAAA,MACP,SAAS;AAAA,MACT,uBAAuB;AAAA,IACzB,CAAC;AAGD,YAAQ,KAAK,CAAC,SAAS;AACrB,YAAM,QAAQ,gBAAgB,MAAM,cAAc,cAAc,gBAAgB,OAAO;AACvF,UAAI,OAAO;AACT,eAAO,KAAK,KAAK;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH,QAAQ;AAEN,WAAO,MAAM,0BAA0B,QAAQ,wBAAwB;AACvE,WAAO,KAAK,GAAG,cAAc,SAAS,cAAc,cAAc,cAAc,CAAC;AAAA,EACnF;AAEA,SAAO;AACT;AAKA,SAAS,gBACP,MACA,MACA,cACA,gBACA,UACiB;AAEjB,MACE,KAAK,SAAS,sBACd,aAAa,KAAK,MAAM,KACxB,KAAK,SAAS,SAAS,cACvB;AACA,UAAM,OAAO,KAAK,SAAS;AAC3B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK,KAAK,MAAM,QAAQ;AAAA,MAC9B,QAAQ,KAAK,KAAK,MAAM,UAAU;AAAA,MAClC,eAAe;AAAA,MACf,cAAc,gBAAgB,iBAAiB,MAAM,cAAc;AAAA,MACnE,cAAc,qBAAqB,IAAI;AAAA,IACzC;AAAA,EACF;AAGA,MACE,KAAK,SAAS,sBACd,aAAa,KAAK,MAAM,KACxB,KAAK,YACL,KAAK,SAAS,SAAS,aACvB,OAAO,KAAK,SAAS,UAAU,UAC/B;AACA,UAAM,OAAO,KAAK,SAAS;AAC3B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK,KAAK,MAAM,QAAQ;AAAA,MAC9B,QAAQ,KAAK,KAAK,MAAM,UAAU;AAAA,MAClC,eAAe;AAAA,MACf,cAAc,gBAAgB,iBAAiB,MAAM,cAAc;AAAA,MACnE,cAAc,qBAAqB,IAAI;AAAA,IACzC;AAAA,EACF;AAGA,MACE,KAAK,SAAS,wBACd,KAAK,GAAG,SAAS,mBACjB,KAAK,QACL,iBAAiB,KAAK,IAAI,GAC1B;AACA,UAAM,SAAqB,CAAC;AAC5B,eAAW,QAAQ,KAAK,GAAG,YAAY;AACrC,UAAI,KAAK,SAAS,cAAc,KAAK,IAAI,SAAS,cAAc;AAC9D,cAAM,OAAO,KAAK,IAAI;AACtB,eAAO,KAAK;AAAA,UACV;AAAA,UACA;AAAA,UACA,MAAM,KAAK,KAAK,MAAM,QAAQ;AAAA,UAC9B,QAAQ,KAAK,KAAK,MAAM,UAAU;AAAA,UAClC,eAAe;AAAA,UACf,cAAc,gBAAgB,iBAAiB,MAAM,cAAc;AAAA,QACrE,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,OAAO,CAAC,KAAK;AAAA,EACtB;AAGA,MACE,KAAK,SAAS,sBACd,aAAa,KAAK,MAAM,KACxB,KAAK,YACL,KAAK,SAAS,SAAS,WACvB;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,MACA,MAAM,KAAK,KAAK,MAAM,QAAQ;AAAA,MAC9B,QAAQ,KAAK,KAAK,MAAM,UAAU;AAAA,MAClC,eAAe;AAAA,MACf,cAAc;AAAA,IAChB;AAAA,EACF;AAGA,MACE,KAAK,SAAS,sBACd,gBAAgB,KAAK,MAAM,KAC3B,KAAK,SAAS,SAAS,cACvB;AACA,UAAM,OAAO,KAAK,SAAS;AAC3B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK,KAAK,MAAM,QAAQ;AAAA,MAC9B,QAAQ,KAAK,KAAK,MAAM,UAAU;AAAA,MAClC,eAAe;AAAA,MACf,cAAc;AAAA;AAAA,IAChB;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,aAAa,MAA8B;AAClD,SACE,KAAK,SAAS,sBACd,KAAK,OAAO,SAAS,gBACrB,KAAK,OAAO,SAAS,aACrB,KAAK,SAAS,SAAS,gBACvB,KAAK,SAAS,SAAS;AAE3B;AAKA,SAAS,iBAAiB,MAA8B;AACtD,SAAO,aAAa,IAAiC;AACvD;AAKA,SAAS,gBAAgB,MAA8B;AACrD,SACE,KAAK,SAAS,sBACd,KAAK,OAAO,SAAS,kBACrB,KAAK,OAAO,KAAK,SAAS,YAC1B,KAAK,OAAO,SAAS,SAAS,UAC9B,KAAK,SAAS,SAAS,gBACvB,KAAK,SAAS,SAAS;AAE3B;AAKA,SAAS,qBACP,MACgE;AAEhE,QAAM,SAAU,KAAoD;AACpE,MAAI,CAAC,OAAQ,QAAO;AAGpB,MACE,OAAO,SAAS,oBAChB,OAAO,OAAO,SAAS,gBACvB,CAAC,YAAY,cAAc,QAAQ,EAAE,SAAS,OAAO,OAAO,IAAI,GAChE;AACA,WAAO;AAAA,EACT;AAGA,MACE,OAAO,SAAS,sBAChB,OAAO,MAAM,SAAS,cACrB,OAAO,MAAM,UAAU,UAAU,OAAO,MAAM,UAAU,UACzD;AACA,WAAO;AAAA,EACT;AAGA,MACE,OAAO,SAAS,oBAChB,OAAO,OAAO,SAAS,sBACvB,OAAO,OAAO,OAAO,SAAS,gBAC9B,OAAO,OAAO,OAAO,SAAS,UAC9B,OAAO,OAAO,SAAS,SAAS,gBAChC,OAAO,OAAO,SAAS,SAAS,SAChC;AACA,WAAO;AAAA,EACT;AAGA,MACE,OAAO,SAAS,sBAChB,OAAO,SAAS,SAAS,gBACzB,OAAO,SAAS,SAAS,SACzB;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAKA,SAAS,iBAAiB,MAAc,UAA6B;AACnE,SAAO,SAAS,KAAK,CAAC,WAAW,KAAK,WAAW,MAAM,CAAC;AAC1D;AAKA,SAAS,iBAAiB,UAA2B;AACnD,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO,eAAe,KAAK,CAAC,YAAY,QAAQ,KAAK,QAAQ,CAAC;AAChE;AAKA,SAAS,QAAQ,MAAqB,SAA8C;AAClF,UAAQ,IAAI;AAEZ,aAAW,OAAO,OAAO,KAAK,IAAI,GAAG;AACnC,UAAM,QAAS,KAA4C,GAAG;AAE9D,QAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,iBAAW,QAAQ,OAAO;AACxB,YAAI,QAAQ,OAAO,SAAS,YAAY,UAAU,MAAM;AACtD,kBAAQ,MAAuB,OAAO;AAAA,QACxC;AAAA,MACF;AAAA,IACF,WAAW,SAAS,OAAO,UAAU,YAAY,UAAU,OAAO;AAChE,cAAQ,OAAwB,OAAO;AAAA,IACzC;AAAA,EACF;AACF;AAKA,SAAS,cACP,SACA,MACA,cACA,gBACY;AACZ,QAAM,SAAqB,CAAC;AAC5B,QAAM,QAAQ,QAAQ,MAAM,IAAI;AAGhC,QAAM,gBAAgB;AAGtB,QAAM,iBAAiB;AAGvB,QAAM,cAAc;AAEpB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,OAAO,MAAM,CAAC;AACpB,UAAM,aAAa,IAAI;AAGvB,QAAI;AACJ,YAAQ,QAAQ,cAAc,KAAK,IAAI,OAAO,MAAM;AAClD,aAAO,KAAK;AAAA,QACV,MAAM,MAAM,CAAC;AAAA,QACb;AAAA,QACA,MAAM;AAAA,QACN,QAAQ,MAAM;AAAA,QACd,eAAe;AAAA,QACf,cAAc,gBAAgB,iBAAiB,MAAM,CAAC,GAAG,cAAc;AAAA,MACzE,CAAC;AAAA,IACH;AAGA,YAAQ,QAAQ,eAAe,KAAK,IAAI,OAAO,MAAM;AACnD,aAAO,KAAK;AAAA,QACV,MAAM,MAAM,CAAC;AAAA,QACb;AAAA,QACA,MAAM;AAAA,QACN,QAAQ,MAAM;AAAA,QACd,eAAe;AAAA,QACf,cAAc,gBAAgB,iBAAiB,MAAM,CAAC,GAAG,cAAc;AAAA,MACzE,CAAC;AAAA,IACH;AAGA,YAAQ,QAAQ,YAAY,KAAK,IAAI,OAAO,MAAM;AAChD,aAAO,KAAK;AAAA,QACV,MAAM,MAAM,CAAC;AAAA,QACb;AAAA,QACA,MAAM;AAAA,QACN,QAAQ,MAAM;AAAA,QACd,eAAe;AAAA,QACf,cAAc;AAAA,MAChB,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;;;AElaA;AAEA;AACA;AAHA,SAAS,WAAAC,gBAAe;AAiBjB,IAAM,aAAgE;AAAA,EAC3E,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,aAAa;AAAA,IACb,WAAW,CAAC,cAAc;AAAA,IAC1B,cAAc,CAAC,cAAc;AAAA,IAC7B,YAAY;AAAA,IACZ,aAAa,CAAC,kBAAkB,mBAAmB,gBAAgB;AAAA,EACrE;AAAA,EACA,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,aAAa;AAAA,IACb,WAAW,CAAC,OAAO;AAAA,IACnB,cAAc,CAAC,OAAO;AAAA,IACtB,YAAY;AAAA,IACZ,aAAa,CAAC,kBAAkB,kBAAkB,iBAAiB;AAAA,EACrE;AAAA,EACA,KAAK;AAAA,IACH,MAAM;AAAA,IACN,aAAa;AAAA,IACb,WAAW,CAAC,YAAY;AAAA,IACxB,cAAc,CAAC,YAAY;AAAA,IAC3B,YAAY;AAAA,IACZ,aAAa,CAAC;AAAA,EAChB;AAAA,EACA,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,aAAa;AAAA,IACb,WAAW,CAAC;AAAA,IACZ,cAAc,CAAC;AAAA,IACf,YAAY;AAAA,IACZ,aAAa,CAAC;AAAA,EAChB;AACF;AAKA,eAAsB,gBAAgB,SAAqC;AACzE,SAAO,MAAM,6BAA6B;AAG1C,aAAW,CAAC,WAAW,IAAI,KAAK,OAAO,QAAQ,UAAU,GAAG;AAC1D,eAAW,cAAc,KAAK,aAAa;AACzC,YAAM,aAAaA,SAAQ,SAAS,UAAU;AAC9C,UAAI,MAAM,WAAW,UAAU,GAAG;AAChC,eAAO,MAAM,YAAY,KAAK,WAAW,QAAQ,UAAU,EAAE;AAC7D,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAGA,QAAM,kBAAkBA,SAAQ,SAAS,cAAc;AACvD,QAAM,cAAc,MAAM,aAGvB,eAAe;AAElB,MAAI,aAAa;AACf,UAAM,UAAU;AAAA,MACd,GAAG,YAAY;AAAA,MACf,GAAG,YAAY;AAAA,IACjB;AAGA,QAAI,UAAU,SAAS;AACrB,aAAO,MAAM,mCAAmC;AAChD,aAAO;AAAA,IACT;AAGA,QAAI,UAAU,SAAS;AACrB,aAAO,MAAM,gCAAgC;AAC7C,aAAO;AAAA,IACT;AAGA,QAAI,mBAAmB,SAAS;AAC9B,aAAO,MAAM,4CAA4C;AACzD,aAAO;AAAA,IACT;AAAA,EACF;AAGA,SAAO,MAAM,uDAAuD;AACpE,SAAO;AACT;;;ACxGA;AAeO,SAAS,eAAe,SAA0C;AACvE,QAAM,EAAE,kBAAkB,eAAe,OAAO,IAAI;AACpD,QAAM,SAAkB,CAAC;AAGzB,QAAM,eAAe,IAAI,IAAI,iBAAiB,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAGhE,QAAM,WAAW,oBAAI,IAAY;AAGjC,aAAW,SAAS,eAAe;AACjC,UAAM,EAAE,KAAK,IAAI;AAGjB,QAAI,SAAS,aAAa;AACxB;AAAA,IACF;AAGA,QAAI,SAAS,IAAI,IAAI,GAAG;AACtB;AAAA,IACF;AAGA,QAAI,aAAa,IAAI,IAAI,GAAG;AAC1B;AAAA,IACF;AAGA,QAAI,qBAAqB,MAAM,OAAO,QAAQ,SAAS,GAAG;AACxD;AAAA,IACF;AAGA,UAAM,YAAY,OAAO,UAAU,IAAI;AACvC,QAAI,WAAW,YAAY,QAAW;AACpC;AAAA,IACF;AAGA,UAAM,aAAa,WAAW,YAAY;AAC1C,UAAM,WAAW,aAAa,UAAU;AAExC,aAAS,IAAI,IAAI;AAEjB,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN;AAAA,MACA,UAAU;AAAA,MACV,SAAS,aAAa,IAAI;AAAA,MAC1B,UAAU;AAAA,QACR,MAAM,MAAM;AAAA,QACZ,MAAM,MAAM;AAAA,QACZ,QAAQ,MAAM;AAAA,MAChB;AAAA,MACA,KAAK,OAAO,IAAI;AAAA,IAClB,CAAC;AAAA,EACH;AAGA,aAAW,CAAC,MAAM,IAAI,KAAK,OAAO,QAAQ,OAAO,SAAS,GAAG;AAC3D,QAAI,CAAC,KAAK,SAAU;AACpB,QAAI,aAAa,IAAI,IAAI,EAAG;AAC5B,QAAI,SAAS,IAAI,IAAI,EAAG;AACxB,QAAI,qBAAqB,MAAM,OAAO,QAAQ,SAAS,EAAG;AAE1D,aAAS,IAAI,IAAI;AAEjB,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAU;AAAA,MACV,SAAS,sBAAsB,IAAI;AAAA,MACnC,KAAK,OAAO,IAAI;AAAA,IAClB,CAAC;AAAA,EACH;AAEA,SAAO;AACT;;;AC9FA;AAiBA,IAAM,sBAAsB,oBAAI,IAAI;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAKD,IAAM,iBAA8C;AAAA,EAClD,QAAQ,oBAAI,IAAI;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAAA,EACD,MAAM,oBAAI,IAAI,CAAC,kBAAkB,yBAAyB,CAAC;AAAA,EAC3D,KAAK,oBAAI,IAAI,CAAC,WAAW,sBAAsB,IAAI,CAAC;AAAA,EACpD,MAAM,oBAAI,IAAI,CAAC,CAAC;AAClB;AAKO,SAAS,cAAc,SAAyC;AACrE,QAAM,EAAE,kBAAkB,eAAe,QAAQ,UAAU,IAAI;AAC/D,QAAM,SAAkB,CAAC;AAGzB,QAAM,YAAY,IAAI;AAAA,IACpB,cAAc,OAAO,CAAC,MAAM,EAAE,SAAS,WAAW,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI;AAAA,EACvE;AAGA,QAAM,gBAAgB,eAAe,SAAS,KAAK,oBAAI,IAAI;AAE3D,aAAW,YAAY,kBAAkB;AACvC,UAAM,EAAE,MAAM,MAAM,KAAK,IAAI;AAG7B,QAAI,UAAU,IAAI,IAAI,GAAG;AACvB;AAAA,IACF;AAGA,QAAI,oBAAoB,IAAI,IAAI,GAAG;AACjC;AAAA,IACF;AAGA,QAAI,cAAc,IAAI,IAAI,GAAG;AAC3B;AAAA,IACF;AAGA,QAAI,qBAAqB,MAAM,OAAO,QAAQ,QAAQ,GAAG;AACvD;AAAA,IACF;AAGA,QAAI,mBAAmB,SAAS,KAAK,GAAG;AACtC;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAU;AAAA,MACV,SAAS,aAAa,IAAI,mBAAmB,IAAI;AAAA,MACjD,UAAU;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,MACA,SAAS;AAAA,QACP,OAAO,SAAS,QAAQ,UAAU;AAAA,MACpC;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAKA,SAAS,mBAAmB,OAAwB;AAClD,MAAI,CAAC,MAAO,QAAO;AAEnB,QAAM,sBAAsB;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO,oBAAoB,KAAK,CAAC,YAAY,QAAQ,KAAK,KAAK,CAAC;AAClE;;;AChIA;AAgBO,SAAS,oBAAoB,SAA+C;AACjF,QAAM,EAAE,kBAAkB,eAAe,OAAO,IAAI;AACpD,QAAM,SAAkB,CAAC;AAGzB,QAAM,aAAa,oBAAI,IAAyB;AAChD,aAAW,YAAY,kBAAkB;AACvC,eAAW,IAAI,SAAS,MAAM,QAAQ;AAAA,EACxC;AAGA,QAAM,eAAe,oBAAI,IAAwB;AACjD,aAAW,SAAS,eAAe;AACjC,QAAI,MAAM,SAAS,YAAa;AAEhC,UAAM,WAAW,aAAa,IAAI,MAAM,IAAI,KAAK,CAAC;AAClD,aAAS,KAAK,KAAK;AACnB,iBAAa,IAAI,MAAM,MAAM,QAAQ;AAAA,EACvC;AAGA,QAAM,UAAU,oBAAI,IAAY;AAEhC,aAAW,CAAC,MAAM,MAAM,KAAK,cAAc;AACzC,QAAI,QAAQ,IAAI,IAAI,EAAG;AACvB,YAAQ,IAAI,IAAI;AAGhB,QAAI,qBAAqB,MAAM,OAAO,QAAQ,eAAe,GAAG;AAC9D;AAAA,IACF;AAEA,UAAM,UAAU,WAAW,IAAI,IAAI;AACnC,QAAI,CAAC,QAAS;AAEd,UAAM,QAAQ,QAAQ;AAGtB,UAAM,YAAY,OAAO,UAAU,IAAI;AACvC,QAAI,WAAW,MAAM;AACnB,YAAM,YAAY,aAAa,MAAM,OAAO,UAAU,MAAM,OAAO;AACnE,UAAI,WAAW;AACb,eAAO,KAAK,SAAS;AACrB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,WAAW,SAAS;AACtB,UAAI,CAAC,UAAU,QAAQ,KAAK,KAAK,GAAG;AAClC,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI;AAAA,UAC1B,UAAU;AAAA,YACR,MAAM,QAAQ;AAAA,YACd,MAAM,QAAQ;AAAA,UAChB;AAAA,UACA,SAAS;AAAA,YACP,SAAS,UAAU,QAAQ,SAAS;AAAA,YACpC,OAAO,mBAAmB,OAAO,QAAQ,QAAQ;AAAA,UACnD;AAAA,QACF,CAAC;AACD;AAAA,MACF;AAAA,IACF;AAGA,QAAI,WAAW,QAAQ,UAAU,KAAK,SAAS,GAAG;AAChD,UAAI,CAAC,UAAU,KAAK,SAAS,KAAK,GAAG;AACnC,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI,qBAAqB,UAAU,KAAK,KAAK,IAAI,CAAC;AAAA,UACxE,UAAU;AAAA,YACR,MAAM,QAAQ;AAAA,YACd,MAAM,QAAQ;AAAA,UAChB;AAAA,UACA,SAAS;AAAA,YACP,UAAU,UAAU;AAAA,YACpB,QAAQ,mBAAmB,OAAO,QAAQ,QAAQ;AAAA,UACpD;AAAA,QACF,CAAC;AACD;AAAA,MACF;AAAA,IACF;AAGA,UAAM,gBAAgB,OACnB,IAAI,CAAC,MAAM,EAAE,YAAY,EACzB,OAAO,CAAC,MAAkC,MAAM,MAAS;AAE5D,QAAI,cAAc,SAAS,GAAG;AAE5B,YAAM,cAAc,kBAAkB,aAAa;AAEnD,UAAI,aAAa;AACf,cAAM,YAAY,qBAAqB,MAAM,OAAO,aAAa,SAAS,OAAO,CAAC,CAAC;AACnF,YAAI,WAAW;AACb,iBAAO,KAAK,SAAS;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,aACP,MACA,OACA,MACA,SACc;AACd,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,UAAI,CAAC,kBAAkB,KAAK,KAAK,GAAG;AAClC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI,mCAAmC,mBAAmB,OAAO,QAAQ,QAAQ,CAAC;AAAA,UACxG,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,KAAK;AAAA,QACP;AAAA,MACF;AACA;AAAA,IAEF,KAAK;AACH,UAAI,CAAC,CAAC,QAAQ,SAAS,KAAK,KAAK,OAAO,IAAI,EAAE,SAAS,MAAM,YAAY,CAAC,GAAG;AAC3E,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI,oCAAoC,mBAAmB,OAAO,QAAQ,QAAQ,CAAC;AAAA,UACzG,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,KAAK;AAAA,QACP;AAAA,MACF;AACA;AAAA,IAEF,KAAK;AACH,UAAI;AACF,aAAK,MAAM,KAAK;AAAA,MAClB,QAAQ;AACN,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI;AAAA,UAC1B,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,KAAK;AAAA,QACP;AAAA,MACF;AACA;AAAA,IAEF,KAAK;AACH,UAAI;AACF,YAAI,IAAI,KAAK;AAAA,MACf,QAAQ;AACN,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI;AAAA,UAC1B,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,KAAK;AAAA,QACP;AAAA,MACF;AACA;AAAA,IAEF,KAAK;AACH,UAAI,CAAC,6BAA6B,KAAK,KAAK,GAAG;AAC7C,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI;AAAA,UAC1B,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,KAAK;AAAA,QACP;AAAA,MACF;AACA;AAAA,EACJ;AAEA,SAAO;AACT;AAKA,SAAS,qBACP,MACA,OACA,cACA,SACA,OACc;AACd,QAAM,aAAa,eAAe,KAAK;AAGvC,MAAI,CAAC,MAAO,QAAO;AAEnB,UAAQ,cAAc;AAAA,IACpB,KAAK;AACH,UAAI,eAAe,UAAU;AAC3B,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI,4BAA4B,MAAM,IAAI,IAAI,MAAM,IAAI,eAAe,mBAAmB,OAAO,QAAQ,QAAQ,CAAC;AAAA,UACxI,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,SAAS;AAAA,YACP,QAAQ,GAAG,MAAM,IAAI,IAAI,MAAM,IAAI;AAAA,UACrC;AAAA,QACF;AAAA,MACF;AACA;AAAA,IAEF,KAAK;AACH,UAAI,CAAC,CAAC,QAAQ,SAAS,KAAK,GAAG,EAAE,SAAS,MAAM,YAAY,CAAC,GAAG;AAC9D,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI,6BAA6B,MAAM,IAAI,IAAI,MAAM,IAAI;AAAA,UAC/E,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,SAAS;AAAA,YACP,QAAQ,GAAG,MAAM,IAAI,IAAI,MAAM,IAAI;AAAA,UACrC;AAAA,QACF;AAAA,MACF;AACA;AAAA,IAEF,KAAK;AACH,UAAI,eAAe,QAAQ;AACzB,YAAI;AACF,eAAK,MAAM,KAAK;AAAA,QAClB,QAAQ;AACN,iBAAO;AAAA,YACL,MAAM;AAAA,YACN,UAAU;AAAA,YACV,UAAU;AAAA,YACV,SAAS,aAAa,IAAI,0BAA0B,MAAM,IAAI,IAAI,MAAM,IAAI;AAAA,YAC5E,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,YACnD,SAAS;AAAA,cACP,QAAQ,GAAG,MAAM,IAAI,IAAI,MAAM,IAAI;AAAA,YACrC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA;AAAA,IAEF,KAAK;AAEH,UAAI,CAAC,MAAM,SAAS,GAAG,GAAG;AACxB,eAAO;AAAA,UACL,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,aAAa,IAAI,4BAA4B,MAAM,IAAI,IAAI,MAAM,IAAI;AAAA,UAC9E,UAAU,EAAE,MAAM,QAAQ,MAAM,MAAM,QAAQ,KAAK;AAAA,UACnD,SAAS;AAAA,YACP,QAAQ,GAAG,MAAM,IAAI,IAAI,MAAM,IAAI;AAAA,UACrC;AAAA,QACF;AAAA,MACF;AACA;AAAA,EACJ;AAEA,SAAO;AACT;AAKA,SAAS,kBAAkB,OAAqC;AAC9D,QAAM,SAAiC,CAAC;AACxC,aAAW,QAAQ,OAAO;AACxB,WAAO,IAAI,KAAK,OAAO,IAAI,KAAK,KAAK;AAAA,EACvC;AAEA,MAAI,WAAW;AACf,MAAI;AACJ,aAAW,CAAC,MAAM,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,QAAI,QAAQ,UAAU;AACpB,iBAAW;AACX,gBAAU;AAAA,IACZ;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,mBAAmB,OAAe,UAA4B;AACrE,MAAI,CAAC,SAAU,QAAO;AAEtB,MAAI,MAAM,UAAU,EAAG,QAAO;AAC9B,SAAO,MAAM,MAAM,GAAG,CAAC,IAAI,SAAS,MAAM,MAAM,EAAE;AACpD;;;ACnUA;AAyBO,SAAS,iBAAiB,SAA4C;AAC3E,QAAM,EAAE,cAAc,mBAAmB,aAAa,IAAI;AAC1D,QAAM,SAAkB,CAAC;AAGzB,QAAM,WAAW,IAAI,IAAI,aAAa,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AACxD,QAAM,gBAAgB,IAAI,IAAI,kBAAkB,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAElE,QAAM,sBAAgC,CAAC;AACvC,QAAM,iBAA2B,CAAC;AAGlC,aAAW,YAAY,cAAc;AACnC,QAAI,CAAC,cAAc,IAAI,SAAS,IAAI,GAAG;AACrC,0BAAoB,KAAK,SAAS,IAAI;AAEtC,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,UAAU;AAAA,QACV,UAAU,SAAS;AAAA,QACnB,SAAS,aAAa,SAAS,IAAI,mBAAmB,SAAS,IAAI,eAAe,YAAY;AAAA,QAC9F,UAAU;AAAA,UACR,MAAM,SAAS;AAAA,UACf,MAAM,SAAS;AAAA,QACjB;AAAA,QACA,KAAK,OAAO,SAAS,IAAI,QAAQ,YAAY;AAAA,MAC/C,CAAC;AAAA,IACH;AAAA,EACF;AAGA,aAAW,YAAY,mBAAmB;AACxC,QAAI,CAAC,SAAS,IAAI,SAAS,IAAI,GAAG;AAChC,qBAAe,KAAK,SAAS,IAAI;AAEjC,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,UAAU;AAAA,QACV,UAAU,SAAS;AAAA,QACnB,SAAS,aAAa,SAAS,IAAI,WAAW,YAAY;AAAA,QAC1D,UAAU;AAAA,UACR,MAAM;AAAA,UACN,MAAM,SAAS;AAAA,QACjB;AAAA,QACA,KAAK,OAAO,SAAS,IAAI;AAAA,MAC3B,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,SAAS,oBAAoB,WAAW,KAAK,eAAe,WAAW;AAE7E,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAKO,SAAS,iBACd,WACA,UAII,CAAC,GACG;AACR,QAAM,EAAE,kBAAkB,MAAM,gBAAgB,MAAM,cAAc,KAAK,IAAI;AAE7E,QAAM,QAAkB,CAAC;AAEzB,MAAI,iBAAiB;AACnB,UAAM,KAAK,kCAAkC;AAC7C,UAAM,KAAK,iDAAiD;AAC5D,UAAM,KAAK,EAAE;AAAA,EACf;AAEA,MAAI,eAAe;AAEjB,UAAM,SAAwC,CAAC;AAE/C,eAAW,YAAY,WAAW;AAChC,YAAM,SAAS,UAAU,SAAS,IAAI;AACtC,UAAI,CAAC,OAAO,MAAM,GAAG;AACnB,eAAO,MAAM,IAAI,CAAC;AAAA,MACpB;AACA,aAAO,MAAM,EAAE,KAAK,QAAQ;AAAA,IAC9B;AAGA,UAAM,eAAe,OAAO,QAAQ,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;AAEjF,eAAW,CAAC,QAAQ,IAAI,KAAK,cAAc;AACzC,UAAI,mBAAmB,QAAQ;AAC7B,cAAM,KAAK,KAAK,iBAAiB,MAAM,CAAC,EAAE;AAAA,MAC5C;AAEA,iBAAW,YAAY,KAAK,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,cAAc,EAAE,IAAI,CAAC,GAAG;AACxE,cAAM,KAAK,uBAAuB,UAAU,WAAW,CAAC;AAAA,MAC1D;AAEA,YAAM,KAAK,EAAE;AAAA,IACf;AAAA,EACF,OAAO;AAEL,UAAM,SAAS,CAAC,GAAG,SAAS,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,cAAc,EAAE,IAAI,CAAC;AAEzE,eAAW,YAAY,QAAQ;AAC7B,YAAM,KAAK,uBAAuB,UAAU,WAAW,CAAC;AAAA,IAC1D;AAAA,EACF;AAEA,SAAO,MAAM,KAAK,IAAI;AACxB;AAKA,SAAS,UAAU,MAAsB;AAEvC,QAAM,WAAW;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,aAAW,UAAU,UAAU;AAC7B,QAAI,KAAK,WAAW,MAAM,GAAG;AAC3B,aAAO;AAAA,IACT;AAAA,EACF;AAGA,QAAM,QAAQ,KAAK,MAAM,GAAG;AAC5B,MAAI,MAAM,SAAS,GAAG;AACpB,WAAO,MAAM,CAAC,IAAI;AAAA,EACpB;AAEA,SAAO;AACT;AAKA,SAAS,iBAAiB,QAAwB;AAChD,SAAO,OACJ,QAAQ,MAAM,EAAE,EAChB,QAAQ,MAAM,GAAG,EACjB,YAAY,EACZ,QAAQ,SAAS,CAAC,MAAM,EAAE,YAAY,CAAC;AAC5C;AAKA,SAAS,uBAAuB,UAAuB,aAA8B;AACnF,MAAI,QAAQ;AAEZ,MAAI,SAAS,SAAS,CAAC,aAAa;AAClC,YAAQ,SAAS;AAAA,EACnB,WAAW,SAAS,UAAU;AAC5B,YAAQ;AAAA,EACV,WAAW,SAAS,OAAO;AAEzB,YAAQ,gBAAgB,QAAQ;AAAA,EAClC;AAEA,SAAO,GAAG,SAAS,IAAI,IAAI,KAAK;AAClC;AAKA,SAAS,gBAAgB,UAA+B;AACtD,QAAM,EAAE,MAAM,MAAM,IAAI;AAGxB,MAAI,KAAK,SAAS,KAAK,KAAK,KAAK,SAAS,KAAK,GAAG;AAChD,QAAI,MAAM,WAAW,aAAa,EAAG,QAAO;AAC5C,QAAI,MAAM,WAAW,UAAU,EAAG,QAAO;AACzC,QAAI,MAAM,WAAW,YAAY,EAAG,QAAO;AAC3C,QAAI,MAAM,WAAW,UAAU,EAAG,QAAO;AACzC,QAAI,MAAM,WAAW,MAAM,EAAG,QAAO;AACrC,WAAO;AAAA,EACT;AAGA,MAAI,QAAQ,KAAK,KAAK,GAAG;AACvB,WAAO;AAAA,EACT;AAGA,MAAI,CAAC,QAAQ,OAAO,EAAE,SAAS,MAAM,YAAY,CAAC,GAAG;AACnD,WAAO;AAAA,EACT;AAGA,MAAI,SAAS,YAAY;AACvB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AC9OA;AAMO,IAAM,uBAAsE;AAAA;AAAA,EAEjF,EAAE,SAAS,YAAY;AAAA,EACvB,EAAE,SAAS,UAAU;AAAA,EACrB,EAAE,SAAS,mBAAmB;AAAA,EAC9B,EAAE,SAAS,eAAe;AAAA,EAC1B,EAAE,SAAS,kBAAkB;AAAA,EAC7B,EAAE,SAAS,oBAAoB;AAAA,EAC/B,EAAE,SAAS,qBAAqB;AAAA,EAChC,EAAE,SAAS,UAAU;AAAA,EACrB,EAAE,SAAS,cAAc;AAAA,EACzB,EAAE,SAAS,yBAAyB;AAAA;AAAA,EAGpC,EAAE,SAAS,gBAAgB,UAAU,MAAM;AAAA,EAC3C,EAAE,SAAS,oBAAoB,UAAU,MAAM;AAAA,EAC/C,EAAE,SAAS,mBAAmB,UAAU,SAAS;AAAA,EACjD,EAAE,SAAS,2BAA2B,UAAU,SAAS;AAAA,EACzD,EAAE,SAAS,kBAAkB,UAAU,SAAS;AAAA,EAChD,EAAE,SAAS,cAAc,UAAU,SAAS;AAAA,EAC5C,EAAE,SAAS,oCAAoC,UAAU,SAAS;AAAA,EAClE,EAAE,SAAS,eAAe,UAAU,WAAW;AAAA,EAC/C,EAAE,SAAS,uBAAuB,UAAU,SAAS;AAAA,EACrD,EAAE,SAAS,sBAAsB,UAAU,WAAW;AAAA,EACtD,EAAE,SAAS,qBAAqB,UAAU,UAAU;AAAA,EACpD,EAAE,SAAS,iBAAiB,UAAU,QAAQ;AAAA,EAC9C,EAAE,SAAS,mBAAmB,UAAU,UAAU;AAAA,EAClD,EAAE,SAAS,oBAAoB,UAAU,SAAS;AAAA,EAClD,EAAE,SAAS,uBAAuB,UAAU,YAAY;AAAA,EACxD,EAAE,SAAS,gBAAgB,UAAU,SAAS;AAAA,EAC9C,EAAE,SAAS,qBAAqB,UAAU,UAAU;AACtD;AAKO,IAAM,wBAAkE;AAAA;AAAA,EAE7E,EAAE,SAAS,6BAA6B,MAAM,yBAAyB;AAAA,EACvE,EAAE,SAAS,6BAA6B,MAAM,yBAAyB;AAAA,EACvE,EAAE,SAAS,6BAA6B,MAAM,wBAAwB;AAAA;AAAA,EAGtE,EAAE,SAAS,qBAAqB,MAAM,iBAAiB;AAAA,EACvD,EAAE,SAAS,wBAAwB,MAAM,0BAA0B;AAAA;AAAA,EAGnE,EAAE,SAAS,wBAAwB,MAAM,+BAA+B;AAAA,EACxE,EAAE,SAAS,wBAAwB,MAAM,qBAAqB;AAAA,EAC9D,EAAE,SAAS,wBAAwB,MAAM,8BAA8B;AAAA,EACvE,EAAE,SAAS,wBAAwB,MAAM,gCAAgC;AAAA,EACzE,EAAE,SAAS,iCAAiC,MAAM,aAAa;AAAA;AAAA,EAG/D,EAAE,SAAS,yDAAyD,MAAM,YAAY;AAAA;AAAA,EAGtF,EAAE,SAAS,mCAAmC,MAAM,kBAAkB;AAAA,EACtE,EAAE,SAAS,kCAAkC,MAAM,iBAAiB;AAAA,EACpE,EAAE,SAAS,uCAAuC,MAAM,sBAAsB;AAAA,EAC9E,EAAE,SAAS,+BAA+B,MAAM,cAAc;AAAA;AAAA,EAG9D,EAAE,SAAS,wBAAwB,MAAM,mBAAmB;AAAA;AAAA,EAG5D;AAAA,IACE,SAAS;AAAA,IACT,MAAM;AAAA,EACR;AAAA;AAAA,EAGA,EAAE,SAAS,0BAA0B,MAAM,iBAAiB;AAAA;AAAA,EAG5D,EAAE,SAAS,6BAA6B,MAAM,cAAc;AAAA;AAAA,EAG5D,EAAE,SAAS,sBAAsB,MAAM,qBAAqB;AAAA,EAC5D,EAAE,SAAS,sBAAsB,MAAM,iBAAiB;AAC1D;AAcO,SAAS,eAAe,SAAyC;AACtE,QAAM,EAAE,WAAW,iBAAiB,CAAC,GAAG,iBAAiB,CAAC,EAAE,IAAI;AAChE,QAAM,SAAkB,CAAC;AAEzB,aAAW,YAAY,WAAW;AAChC,UAAM,EAAE,MAAM,OAAO,MAAM,MAAM,SAAS,IAAI;AAG9C,QAAI,qBAAqB,MAAM,gBAAgB,QAAQ,GAAG;AACxD;AAAA,IACF;AAGA,QAAI,YAAY,CAAC,OAAO;AACtB;AAAA,IACF;AAGA,UAAM,YAAY,sBAAsB,IAAI;AAC5C,UAAM,aAAa,QAAQ,uBAAuB,KAAK,IAAI;AAG3D,UAAM,cAAc,eAAe,KAAK,CAAC,MAAM,EAAE,KAAK,IAAI,KAAM,SAAS,EAAE,KAAK,KAAK,CAAE;AAEvF,SAAK,aAAa,cAAc,gBAAgB,OAAO;AAErD,YAAM,WAAW,WAAW;AAC5B,YAAM,aAAa,YAAY;AAE/B,UAAI,UAAU,aAAa,IAAI;AAC/B,UAAI,UAAU;AACZ,mBAAW,KAAK,QAAQ;AAAA,MAC1B;AACA,UAAI,YAAY;AACd,mBAAW,kBAAkB,UAAU;AAAA,MACzC;AAGA,UAAI,CAACC,oBAAmB,KAAK,GAAG;AAC9B,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,UAAU;AAAA,UACV,UAAU;AAAA,UACV,SAAS,UAAU;AAAA,UACnB,UAAU,EAAE,MAAM,KAAK;AAAA,UACvB,SAAS;AAAA,YACP;AAAA,YACA;AAAA,YACA,cAAc,YAAY,KAAK;AAAA,UACjC;AAAA,UACA,KAAK;AAAA,QACP,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,sBAAsB,MAA6D;AAC1F,aAAW,EAAE,SAAS,SAAS,KAAK,sBAAsB;AACxD,QAAI,QAAQ,KAAK,IAAI,GAAG;AACtB,aAAO,EAAE,SAAS,SAAS;AAAA,IAC7B;AAAA,EACF;AACA,SAAO;AACT;AAKA,SAAS,uBAAuB,OAAyD;AACvF,aAAW,EAAE,SAAS,KAAK,KAAK,uBAAuB;AACrD,QAAI,QAAQ,KAAK,KAAK,GAAG;AACvB,aAAO,EAAE,SAAS,KAAK;AAAA,IACzB;AAAA,EACF;AACA,SAAO;AACT;AAKA,SAASA,oBAAmB,OAAwB;AAClD,QAAM,sBAAsB;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO,oBAAoB,KAAK,CAAC,YAAY,QAAQ,KAAK,KAAK,CAAC;AAClE;AAKA,SAAS,YAAY,OAAuB;AAC1C,MAAI,MAAM,UAAU,GAAG;AACrB,WAAO;AAAA,EACT;AACA,SAAO,MAAM,MAAM,GAAG,CAAC,IAAI,QAAQ,MAAM,MAAM,EAAE;AACnD;AA2CO,SAAS,2BAA2B,QAA2B;AACpE,QAAM,kBAA4B,CAAC;AAEnC,QAAM,eAAe,OAAO,OAAO,CAAC,MAAM,EAAE,SAAS,gBAAgB;AAErE,MAAI,aAAa,SAAS,GAAG;AAC3B,oBAAgB,KAAK,4DAA4D;AACjF,oBAAgB,KAAK,wFAAwF;AAC7G,oBAAgB,KAAK,4DAA4D;AACjF,oBAAgB,KAAK,mEAAmE;AAAA,EAC1F;AAGA,QAAM,YAAY,IAAI;AAAA,IACpB,aAAa,IAAI,CAAC,MAAO,EAAE,SAAmC,QAAQ,EAAE,OAAO,OAAO;AAAA,EACxF;AAEA,MAAI,UAAU,IAAI,KAAK,GAAG;AACxB,oBAAgB,KAAK,oEAAoE;AAAA,EAC3F;AAEA,MAAI,UAAU,IAAI,QAAQ,GAAG;AAC3B,oBAAgB,KAAK,uEAAuE;AAAA,EAC9F;AAEA,SAAO;AACT;;;ATjRA;AAUA,eAAsB,QAAQ,SAAkD;AAC9E,QAAM,EAAE,QAAQ,UAAU,MAAM,IAAI;AACpC,QAAM,YAAY,KAAK,IAAI;AAC3B,QAAM,UAAU,OAAO,QAAQ,QAAQ,IAAI;AAE3C,MAAI,SAAS;AACX,WAAO,WAAW,IAAI;AAAA,EACxB;AAEA,SAAO,MAAM,sBAAsB;AACnC,SAAO,MAAM,mBAAmB,OAAO,EAAE;AAGzC,MAAI,YAAY,OAAO;AACvB,MAAI,cAAc,QAAQ;AACxB,gBAAY,MAAM,gBAAgB,OAAO;AACzC,WAAO,MAAM,4BAA4B,SAAS,EAAE;AAAA,EACtD;AAGA,SAAO,MAAM,sBAAsB,OAAO,SAAS,KAAK,IAAI,CAAC,EAAE;AAC/D,QAAM,YAAY,MAAM,cAAc,OAAO,UAAU,OAAO;AAC9D,QAAM,mBAAkC,UAAU;AAElD,MAAI,UAAU,OAAO,SAAS,GAAG;AAC/B,WAAO,MAAM,uBAAuB,UAAU,OAAO,MAAM,EAAE;AAAA,EAC/D;AAGA,MAAI;AACJ,MAAI,OAAO,cAAc;AACvB,WAAO,MAAM,0BAA0B,OAAO,YAAY,EAAE;AAC5D,UAAM,iBAAiB,MAAM,aAAa,OAAO,cAAc,OAAO;AACtE,QAAI,eAAe,UAAU,SAAS,GAAG;AACvC,0BAAoB,eAAe;AAAA,IACrC;AAAA,EACF;AAGA,SAAO,MAAM,gCAAgC;AAC7C,QAAM,aAAa,MAAM,SAAS;AAAA,IAChC;AAAA,IACA,SAAS,OAAO;AAAA,IAChB,SAAS,OAAO;AAAA,IAChB;AAAA,EACF,CAAC;AACD,QAAM,gBAA4B,WAAW;AAE7C,SAAO,MAAM,SAAS,cAAc,MAAM,kBAAkB,WAAW,YAAY,QAAQ;AAG3F,QAAM,SAAkB,CAAC;AAGzB,SAAO,MAAM,gCAAgC;AAC7C,QAAM,gBAAgB,eAAe;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,SAAO,KAAK,GAAG,aAAa;AAG5B,SAAO,MAAM,+BAA+B;AAC5C,QAAM,eAAe,cAAc;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,SAAO,KAAK,GAAG,YAAY;AAG3B,SAAO,MAAM,8BAA8B;AAC3C,QAAM,qBAAqB,oBAAoB;AAAA,IAC7C;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,SAAO,KAAK,GAAG,kBAAkB;AAGjC,MAAI,mBAAmB;AACrB,WAAO,MAAM,yBAAyB;AACtC,UAAM,aAAa,iBAAiB;AAAA,MAClC,cAAc;AAAA,MACd;AAAA,MACA,cAAc,OAAO;AAAA,IACvB,CAAC;AACD,WAAO,KAAK,GAAG,WAAW,MAAM;AAAA,EAClC;AAGA,SAAO,MAAM,sBAAsB;AACnC,QAAM,eAAe,eAAe;AAAA,IAClC,WAAW;AAAA,IACX,gBAAgB,OAAO;AAAA,IACvB,gBAAgB,OAAO;AAAA,EACzB,CAAC;AACD,SAAO,KAAK,GAAG,YAAY;AAG3B,QAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,QAAM,aAAa,OAAO,OAAO,CAAC,MAAM,EAAE,aAAa,OAAO,EAAE;AAChE,QAAM,eAAe,OAAO,OAAO,CAAC,MAAM,EAAE,aAAa,SAAS,EAAE;AACpE,QAAM,YAAY,OAAO,OAAO,CAAC,MAAM,EAAE,aAAa,MAAM,EAAE;AAE9D,SAAO,MAAM,wBAAwB,QAAQ,IAAI;AACjD,SAAO,MAAM,SAAS,OAAO,MAAM,YAAY,UAAU,YAAY,YAAY,cAAc,SAAS,QAAQ;AAEhH,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO;AAAA,MACL,cAAc,WAAW;AAAA,MACzB,gBAAgB,OAAO,SAAS;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;AUhJA;AAAA,OAAOC,SAAQ;AAGf,IAAM,iBAA2C;AAAA,EAC/C,OAAOA,IAAG,IAAI,QAAG;AAAA,EACjB,SAASA,IAAG,OAAO,QAAG;AAAA,EACtB,MAAMA,IAAG,KAAK,QAAG;AACnB;AAEA,IAAM,kBAA8D;AAAA,EAClE,OAAOA,IAAG;AAAA,EACV,SAASA,IAAG;AAAA,EACZ,MAAMA,IAAG;AACX;AAEA,IAAM,oBAA+C;AAAA,EACnD,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,iBAAiB;AAAA,EACjB,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,kBAAkB;AACpB;AAcO,SAAS,gBACd,QACA,UAAkC,CAAC,GAC7B;AACN,QAAM,EAAE,UAAU,OAAO,uBAAuB,GAAG,IAAI;AAGvD,UAAQ,IAAI;AACZ,UAAQ,IAAIA,IAAG,KAAKA,IAAG,KAAK,YAAY,CAAC,IAAIA,IAAG,KAAK,SAAS,CAAC;AAC/D,UAAQ,IAAI;AAGZ,QAAM,eAAe,kBAAkB,OAAO,MAAM;AAGpD,UAAQ,IAAIA,IAAG,KAAK,cAAc,OAAO,SAAS,EAAE,CAAC;AACrD,UAAQ;AAAA,IACNA,IAAG;AAAA,MACD,WAAW,OAAO,MAAM,YAAY,WAAW,OAAO,iBAAiB,MAAM;AAAA,IAC/E;AAAA,EACF;AACA,UAAQ,IAAI;AAGZ,MAAI,YAAY;AAEhB,aAAW,CAAC,MAAM,MAAM,KAAK,OAAO,QAAQ,YAAY,GAAG;AACzD,QAAI,OAAO,WAAW,EAAG;AACzB,gBAAY;AAEZ,UAAM,QAAQ,kBAAkB,IAAiB,KAAK;AACtD,UAAM,WAAW,OAAO,CAAC,EAAE;AAC3B,UAAM,OAAO,eAAe,QAAQ;AACpC,UAAM,QAAQ,gBAAgB,QAAQ;AAEtC,YAAQ,IAAI,MAAMA,IAAG,KAAK,GAAG,IAAI,IAAI,KAAK,KAAK,OAAO,MAAM,IAAI,OAAO,WAAW,IAAI,UAAU,QAAQ,GAAG,CAAC,CAAC;AAC7G,YAAQ,IAAI;AAEZ,UAAM,gBAAgB,OAAO,MAAM,GAAG,oBAAoB;AAC1D,eAAW,SAAS,eAAe;AACjC,iBAAW,OAAO,OAAO;AAAA,IAC3B;AAEA,QAAI,OAAO,SAAS,sBAAsB;AACxC,cAAQ;AAAA,QACNA,IAAG,KAAK,aAAa,OAAO,SAAS,oBAAoB,OAAO;AAAA,MAClE;AAAA,IACF;AAEA,YAAQ,IAAI;AAAA,EACd;AAGA,MAAI,CAAC,aAAa,YAAY,GAAG,UAAU,OAAO,mBAAmB;AACnE,YAAQ,IAAIA,IAAG,MAAM,SAAI,IAAIA,IAAG,KAAK,YAAY,CAAC;AAClD,YAAQ,IAAIA,IAAG,KAAK,iCAAiC,CAAC;AACtD,YAAQ,IAAI;AAAA,EACd;AAGA,eAAa,MAAM;AAGnB,MAAI,OAAO,MAAM,aAAa,GAAG;AAC/B,YAAQ,IAAI;AACZ,YAAQ,IAAIA,IAAG,KAAK,kBAAkB,CAAC;AACvC,YAAQ,IAAIA,IAAG,KAAK,wDAAwD,CAAC;AAC7E,YAAQ,IAAIA,IAAG,KAAK,yDAAyD,CAAC;AAAA,EAChF;AAEA,MAAI,CAAC,WAAW;AACd,YAAQ,IAAIA,IAAG,MAAMA,IAAG,KAAK,yBAAoB,CAAC,CAAC;AACnD,YAAQ,IAAI;AAAA,EACd;AACF;AAKA,SAAS,WAAW,OAAc,SAAwB;AACxD,QAAM,EAAE,UAAU,SAAS,UAAU,IAAI,IAAI;AAG7C,UAAQ,IAAI,KAAKA,IAAG,KAAK,QAAQ,CAAC,EAAE;AAGpC,UAAQ,IAAI,OAAOA,IAAG,KAAK,OAAO,CAAC,EAAE;AAGrC,MAAI,UAAU;AACZ,UAAM,MAAM,SAAS,SACjB,GAAG,SAAS,IAAI,IAAI,SAAS,IAAI,IAAI,SAAS,MAAM,KACpD,GAAG,SAAS,IAAI,IAAI,SAAS,IAAI;AACrC,YAAQ,IAAI,OAAOA,IAAG,IAAI,IAAI,CAAC,IAAIA,IAAG,KAAK,GAAG,CAAC,EAAE;AAAA,EACnD;AAGA,MAAI,OAAO,SAAS;AAClB,YAAQ,IAAI,OAAOA,IAAG,MAAM,MAAM,CAAC,IAAI,GAAG,EAAE;AAAA,EAC9C;AAEA,UAAQ,IAAI;AACd;AAKA,SAAS,aAAa,QAA8B;AAClD,QAAM,EAAE,YAAY,cAAc,WAAW,SAAS,IAAI,OAAO;AAEjE,UAAQ,IAAIA,IAAG,KAAK,SAAI,OAAO,EAAE,CAAC,CAAC;AACnC,UAAQ,IAAI;AAEZ,QAAM,QAAkB,CAAC;AAEzB,MAAI,aAAa,GAAG;AAClB,UAAM,KAAKA,IAAG,IAAI,GAAG,UAAU,IAAI,eAAe,IAAI,UAAU,QAAQ,EAAE,CAAC;AAAA,EAC7E;AACA,MAAI,eAAe,GAAG;AACpB,UAAM,KAAKA,IAAG,OAAO,GAAG,YAAY,IAAI,iBAAiB,IAAI,YAAY,UAAU,EAAE,CAAC;AAAA,EACxF;AACA,MAAI,YAAY,GAAG;AACjB,UAAM,KAAKA,IAAG,KAAK,GAAG,SAAS,OAAO,CAAC;AAAA,EACzC;AAEA,MAAI,MAAM,SAAS,GAAG;AACpB,YAAQ,IAAI,YAAY,MAAM,KAAK,IAAI,CAAC,EAAE;AAAA,EAC5C,OAAO;AACL,YAAQ,IAAIA,IAAG,MAAM,6BAA6B,CAAC;AAAA,EACrD;AAEA,UAAQ,IAAIA,IAAG,KAAK,gBAAgB,QAAQ,IAAI,CAAC;AACjD,UAAQ,IAAI;AACd;AAKA,SAAS,kBAAkB,QAA0C;AACnE,QAAM,SAAkC,CAAC;AAGzC,aAAW,QAAQ,OAAO,KAAK,iBAAiB,GAAG;AACjD,WAAO,IAAI,IAAI,CAAC;AAAA,EAClB;AAEA,aAAW,SAAS,QAAQ;AAC1B,QAAI,CAAC,OAAO,MAAM,IAAI,GAAG;AACvB,aAAO,MAAM,IAAI,IAAI,CAAC;AAAA,IACxB;AACA,WAAO,MAAM,IAAI,EAAE,KAAK,KAAK;AAAA,EAC/B;AAEA,SAAO;AACT;AAKO,SAAS,YAAY,QAA8B;AACxD,aAAW,SAAS,OAAO,QAAQ;AACjC,UAAM,QAAQ,MAAM,aAAa,UAAU,UAAU,MAAM,aAAa,YAAY,YAAY;AAChG,UAAM,WAAW,MAAM,WACnB,GAAG,MAAM,SAAS,IAAI,IAAI,MAAM,SAAS,IAAI,KAC7C;AAGJ,QAAI,QAAQ,IAAI,gBAAgB;AAC9B,cAAQ,IAAI,KAAK,KAAK,SAAS,QAAQ,KAAK,MAAM,OAAO,EAAE;AAAA,IAC7D,OAAO;AACL,cAAQ,IAAI,IAAI,MAAM,YAAY,CAAC,KAAK,WAAW,WAAW,OAAO,EAAE,GAAG,MAAM,OAAO,EAAE;AAAA,IAC3F;AAAA,EACF;AAGA,QAAM,EAAE,YAAY,aAAa,IAAI,OAAO;AAC5C,MAAI,aAAa,GAAG;AAClB,YAAQ,IAAI;AAAA,QAAW,UAAU,iBAAiB,YAAY,aAAa;AAAA,EAC7E;AACF;AAKO,SAAS,cAAc,MAI5B;AACA,QAAM,SAAS,CAAC,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,QAAG;AAChE,MAAI,aAAa;AACjB,MAAI,aAAoC;AACxC,MAAI,cAAc;AAClB,QAAM,QAAQ,QAAQ,OAAO;AAE7B,SAAO;AAAA,IACL,QAAQ;AACN,UAAI,OAAO;AACT,gBAAQ,OAAO,MAAM,GAAGA,IAAG,KAAK,OAAO,UAAU,CAAC,CAAC,IAAI,WAAW,EAAE;AACpE,qBAAa,YAAY,MAAM;AAC7B,wBAAc,aAAa,KAAK,OAAO;AACvC,kBAAQ,OAAO,YAAY,CAAC;AAC5B,kBAAQ,OAAO,WAAW,CAAC;AAC3B,kBAAQ,OAAO,MAAM,GAAGA,IAAG,KAAK,OAAO,UAAU,CAAC,CAAC,IAAI,WAAW,EAAE;AAAA,QACtE,GAAG,EAAE;AAAA,MACP,OAAO;AACL,gBAAQ,IAAI,GAAGA,IAAG,KAAK,KAAK,CAAC,IAAI,WAAW,EAAE;AAAA,MAChD;AAAA,IACF;AAAA,IACA,KAAK,UAAU,MAAM;AACnB,UAAI,YAAY;AACd,sBAAc,UAAU;AACxB,qBAAa;AAAA,MACf;AACA,YAAM,OAAO,UAAUA,IAAG,MAAM,QAAG,IAAIA,IAAG,IAAI,QAAG;AACjD,UAAI,OAAO;AACT,gBAAQ,OAAO,YAAY,CAAC;AAC5B,gBAAQ,OAAO,WAAW,CAAC;AAAA,MAC7B;AACA,cAAQ,IAAI,GAAG,IAAI,IAAI,WAAW,EAAE;AAAA,IACtC;AAAA,IACA,OAAO,SAAiB;AACtB,oBAAc;AAAA,IAChB;AAAA,EACF;AACF;;;ACtQA;AAyDO,SAAS,aAAa,QAAoC;AAC/D,SAAO;AAAA,IACL,SAAS;AAAA,IACT,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IAClC,WAAW,OAAO;AAAA,IAClB,SAAS;AAAA,MACP,aAAa,OAAO,OAAO;AAAA,MAC3B,QAAQ,OAAO,MAAM;AAAA,MACrB,UAAU,OAAO,MAAM;AAAA,MACvB,MAAM,OAAO,MAAM;AAAA,MACnB,cAAc,OAAO,MAAM;AAAA,MAC3B,gBAAgB,OAAO,MAAM;AAAA,MAC7B,UAAU,OAAO,MAAM;AAAA,IACzB;AAAA,IACA,QAAQ,OAAO,OAAO,IAAI,WAAW;AAAA,IACrC,WAAW;AAAA,MACT,SAAS,OAAO,iBAAiB,IAAI,CAAC,OAAO;AAAA,QAC3C,MAAM,EAAE;AAAA,QACR,MAAM,EAAE;AAAA,QACR,MAAM,EAAE;AAAA,QACR,UAAU,QAAQ,EAAE,KAAK;AAAA,QACzB,UAAU,EAAE,YAAY;AAAA,MAC1B,EAAE;AAAA,MACF,MAAM,OAAO,cAAc,IAAI,CAAC,OAAO;AAAA,QACrC,MAAM,EAAE;AAAA,QACR,MAAM,EAAE;AAAA,QACR,MAAM,EAAE;AAAA,QACR,eAAe,EAAE;AAAA,QACjB,cAAc,EAAE,gBAAgB;AAAA,MAClC,EAAE;AAAA,IACJ;AAAA,EACF;AACF;AAKA,SAAS,YAAY,OAAyB;AAC5C,SAAO;AAAA,IACL,MAAM,MAAM;AAAA,IACZ,UAAU,MAAM;AAAA,IAChB,UAAU,MAAM;AAAA,IAChB,SAAS,MAAM;AAAA,IACf,UAAU,MAAM;AAAA,IAChB,KAAK,MAAM;AAAA,IACX,SAAS,MAAM;AAAA,EACjB;AACF;AAKO,SAAS,aAAa,QAAgC;AAC3D,QAAM,SAAS,aAAa,MAAM;AAClC,SAAO,KAAK,UAAU,QAAQ,MAAM,CAAC;AACvC;;;AChHA;AAEA,IAAM,YAAY;AAClB,IAAM,eAAe;AACrB,IAAM,gBAAgB;AAKtB,IAAM,mBAA2G;AAAA,EAC/G,SAAS;AAAA,IACP,MAAM;AAAA,IACN,kBAAkB;AAAA,IAClB,iBACE;AAAA,EACJ;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,kBAAkB;AAAA,IAClB,iBACE;AAAA,EACJ;AAAA,EACA,iBAAiB;AAAA,IACf,MAAM;AAAA,IACN,kBAAkB;AAAA,IAClB,iBACE;AAAA,EACJ;AAAA,EACA,cAAc;AAAA,IACZ,MAAM;AAAA,IACN,kBAAkB;AAAA,IAClB,iBACE;AAAA,EACJ;AAAA,EACA,kBAAkB;AAAA,IAChB,MAAM;AAAA,IACN,kBAAkB;AAAA,IAClB,iBACE;AAAA,EACJ;AAAA,EACA,iBAAiB;AAAA,IACf,MAAM;AAAA,IACN,kBAAkB;AAAA,IAClB,iBACE;AAAA,EACJ;AAAA,EACA,kBAAkB;AAAA,IAChB,MAAM;AAAA,IACN,kBAAkB;AAAA,IAClB,iBACE;AAAA,EACJ;AACF;AAKA,SAAS,gBAAgB,UAAgD;AACvE,UAAQ,UAAU;AAAA,IAChB,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAKA,SAAS,gBAAgB,MAA+C;AACtE,UAAQ,MAAM;AAAA,IACZ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAKA,SAAS,YAAY,QAA8B;AACjD,QAAM,YAAY,IAAI,IAAI,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AACnD,QAAM,QAAqB,CAAC;AAE5B,aAAW,QAAQ,WAAW;AAC5B,UAAM,MAAM,iBAAiB,IAAI;AACjC,QAAI,KAAK;AACP,YAAM,KAAK;AAAA,QACT,IAAI,cAAc,IAAI;AAAA,QACtB,MAAM,IAAI;AAAA,QACV,kBAAkB,EAAE,MAAM,IAAI,iBAAiB;AAAA,QAC/C,iBAAiB,EAAE,MAAM,IAAI,gBAAgB;AAAA,QAC7C,sBAAsB,EAAE,OAAO,gBAAgB,IAAI,EAAE;AAAA,QACrD,SAAS,GAAG,aAAa,IAAI,IAAI;AAAA,MACnC,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,cAAc,OAA2B;AAChD,QAAM,WAAW,MAAM,YAAY,EAAE,MAAM,QAAQ,MAAM,EAAE;AAE3D,SAAO;AAAA,IACL,QAAQ,cAAc,MAAM,IAAI;AAAA,IAChC,OAAO,gBAAgB,MAAM,QAAQ;AAAA,IACrC,SAAS,EAAE,MAAM,MAAM,QAAQ;AAAA,IAC/B,WAAW;AAAA,MACT;AAAA,QACE,kBAAkB;AAAA,UAChB,kBAAkB,EAAE,KAAK,SAAS,KAAK;AAAA,UACvC,QAAQ;AAAA,YACN,WAAW,SAAS;AAAA,YACpB,aAAa,SAAS;AAAA,UACxB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAKO,SAAS,QAAQ,QAAqC;AAC3D,QAAM,MAAgB;AAAA,IACpB,MAAM;AAAA,MACJ,QAAQ;AAAA,QACN,MAAM;AAAA,QACN,SAAS;AAAA,QACT,gBAAgB;AAAA,QAChB,OAAO,YAAY,OAAO,MAAM;AAAA,MAClC;AAAA,IACF;AAAA,IACA,SAAS,OAAO,OAAO,IAAI,aAAa;AAAA,EAC1C;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,IACT,SAAS;AAAA,IACT,MAAM,CAAC,GAAG;AAAA,EACZ;AACF;AAKO,SAAS,cAAc,QAAgC;AAC5D,QAAM,QAAQ,QAAQ,MAAM;AAC5B,SAAO,KAAK,UAAU,OAAO,MAAM,CAAC;AACtC;;;ACrKA;AAEA;AAFA,OAAO,eAA8B;AAOrC,IAAMC,yBAAwB;AAAA;AAAA,EAE5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AACF;AAKA,IAAM,mBAAmB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAgBA,eAAsB,eAAe,SAGlC;AACD,QAAM,EAAE,SAAS,QAAQ,KAAK,MAAM,IAAI;AACxC,QAAM,UAA2B,CAAC;AAElC,MAAI;AACJ,MAAI;AACF,UAAM,UAAU,OAAO;AAGvB,UAAM,SAAS,MAAM,IAAI,YAAY;AACrC,QAAI,CAAC,QAAQ;AACX,aAAO,EAAE,SAAS,CAAC,GAAG,OAAO,uBAAuB;AAAA,IACtD;AAAA,EACF,SAAS,KAAK;AACZ,UAAM,UAAU,eAAe,QAAQ,IAAI,UAAU;AACrD,WAAO,EAAE,SAAS,CAAC,GAAG,OAAO,6BAA6B,OAAO,GAAG;AAAA,EACtE;AAEA,MAAI;AAEF,UAAM,aAAa;AAAA,MACjB,IAAI,KAAK;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA;AAAA,IACF;AAEA,QAAI,SAAS,MAAM,SAAS,GAAG;AAC7B,iBAAW,KAAK,MAAM,GAAG,KAAK;AAAA,IAChC;AAEA,UAAM,MAAM,MAAM,IAAI,IAAI,UAAU;AAGpC,UAAM,UAAU,YAAY,GAAG;AAE/B,eAAW,UAAU,SAAS;AAE5B,YAAM,UAAU,kBAAkB,OAAO,IAAI;AAE7C,iBAAW,UAAU,SAAS;AAC5B,gBAAQ,KAAK;AAAA,UACX,QAAQ,OAAO;AAAA,UACf,QAAQ,OAAO;AAAA,UACf,MAAM,OAAO;AAAA,UACb,MAAM,OAAO;AAAA,UACb,MAAM,OAAO;AAAA,UACb,UAAU,OAAO;AAAA,UACjB,eAAeC,aAAY,OAAO,KAAK;AAAA,QACzC,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,MAAM,WAAW,QAAQ,MAAM,mBAAmB,QAAQ,MAAM,oBAAoB;AAAA,EAC7F,SAAS,KAAK;AACZ,UAAM,UAAU,eAAe,QAAQ,IAAI,UAAU;AACrD,WAAO,EAAE,SAAS,OAAO,mBAAmB,OAAO,GAAG;AAAA,EACxD;AAEA,SAAO,EAAE,QAAQ;AACnB;AAYA,SAAS,YAAY,KAA6B;AAChD,QAAM,UAA0B,CAAC;AACjC,QAAM,cAAc;AAEpB,MAAI;AACJ,UAAQ,QAAQ,YAAY,KAAK,GAAG,OAAO,MAAM;AAC/C,YAAQ,KAAK;AAAA,MACX,MAAM,MAAM,CAAC;AAAA,MACb,QAAQ,MAAM,CAAC;AAAA,MACf,MAAM,MAAM,CAAC;AAAA,MACb,MAAM,MAAM,CAAC;AAAA,IACf,CAAC;AAAA,EACH;AAGA,MAAI,QAAQ,WAAW,GAAG;AACxB,UAAM,QAAQ,IAAI,MAAM,IAAI;AAC5B,QAAI,gBAAqC;AACzC,QAAI,YAAsB,CAAC;AAE3B,eAAW,QAAQ,OAAO;AACxB,YAAM,cAAc,KAAK,MAAM,iCAAiC;AAChE,UAAI,aAAa;AACf,YAAI,eAAe;AACjB,wBAAc,OAAO,UAAU,KAAK,IAAI;AACxC,kBAAQ,KAAK,aAAa;AAAA,QAC5B;AACA,wBAAgB;AAAA,UACd,MAAM,YAAY,CAAC;AAAA,UACnB,QAAQ,YAAY,CAAC;AAAA,UACrB,MAAM,YAAY,CAAC;AAAA,UACnB,MAAM;AAAA,QACR;AACA,oBAAY,CAAC;AAAA,MACf,WAAW,eAAe;AACxB,kBAAU,KAAK,IAAI;AAAA,MACrB;AAAA,IACF;AAEA,QAAI,eAAe;AACjB,oBAAc,OAAO,UAAU,KAAK,IAAI;AACxC,cAAQ,KAAK,aAAa;AAAA,IAC5B;AAAA,EACF;AAEA,SAAO;AACT;AAYA,SAAS,kBAAkB,MAA6B;AACtD,QAAM,UAAyB,CAAC;AAChC,QAAM,QAAQ,KAAK,MAAM,IAAI;AAE7B,MAAI,cAAc;AAClB,MAAI,aAAa;AAEjB,aAAW,QAAQ,OAAO;AAExB,UAAM,YAAY,KAAK,MAAM,kBAAkB;AAC/C,QAAI,WAAW;AACb,oBAAc,UAAU,CAAC;AACzB,mBAAa;AACb;AAAA,IACF;AAGA,UAAM,YAAY,KAAK,MAAM,2BAA2B;AACxD,QAAI,WAAW;AACb,mBAAa,SAAS,UAAU,CAAC,GAAG,EAAE,IAAI;AAC1C;AAAA,IACF;AAGA,QAAI,KAAK,WAAW,GAAG,KAAK,CAAC,KAAK,WAAW,KAAK,GAAG;AACnD;AAGA,UAAI,UAAU,WAAW,KAAK,mBAAmB,IAAI,GAAG;AACtD,cAAM,WAAW,KAAK,MAAM,gCAAgC;AAC5D,YAAI,UAAU;AACZ,gBAAM,CAAC,EAAE,UAAU,KAAK,IAAI;AAG5B,cAAI,eAAe,UAAU,KAAK,GAAG;AACnC,oBAAQ,KAAK;AAAA,cACX,MAAM;AAAA,cACN,MAAM;AAAA,cACN;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF,WAAW,CAAC,KAAK,WAAW,GAAG,GAAG;AAChC;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,UAAU,UAA2B;AAC5C,QAAM,cAAc,CAAC,UAAU,UAAU,SAAS;AAClD,SAAO,YAAY,KAAK,CAAC,YAAY,QAAQ,KAAK,QAAQ,CAAC;AAC7D;AAKA,SAAS,mBAAmB,MAAuB;AACjD,SAAO,sBAAsB,KAAK,IAAI;AACxC;AAKA,SAAS,eAAe,UAAkB,OAAwB;AAEhE,aAAW,WAAW,kBAAkB;AACtC,QAAI,QAAQ,KAAK,QAAQ,GAAG;AAC1B,aAAO;AAAA,IACT;AAAA,EACF;AAGA,aAAW,WAAWD,wBAAuB;AAC3C,QAAI,QAAQ,KAAK,KAAK,GAAG;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AAGA,MAAI,MAAM,SAAS,MAAM,eAAe,KAAK,GAAG;AAC9C,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAKA,SAAS,eAAe,KAAsB;AAC5C,QAAM,aAAqC,CAAC;AAC5C,aAAW,QAAQ,KAAK;AACtB,eAAW,IAAI,KAAK,WAAW,IAAI,KAAK,KAAK;AAAA,EAC/C;AAEA,QAAM,cAAc,OAAO,KAAK,UAAU,EAAE;AAC5C,QAAM,QAAQ,cAAc,IAAI;AAGhC,SAAO,QAAQ,OAAO,cAAc;AACtC;AAKA,SAASC,aAAY,OAAuB;AAC1C,MAAI,MAAM,UAAU,GAAG;AACrB,WAAO;AAAA,EACT;AAEA,QAAM,eAAe,MAAM,MAAM,GAAG,CAAC;AACrC,QAAM,aAAa,MAAM,MAAM,EAAE;AACjC,SAAO,GAAG,YAAY,MAAM,UAAU;AACxC;;;Ad3SA;AACA;AAGA,IAAM,UAAU;AAEhB,IAAM,UAAU,IAAI,QAAQ;AAE5B,QACG,KAAK,YAAY,EACjB,YAAY,6DAA6D,EACzE,QAAQ,OAAO;AAGlB,QACG,SAAS,eAAe,qBAAqB,QAAQ,IAAI,CAAC,EAC1D,OAAO,uBAAuB,qBAAqB,EACnD,OAAO,2BAA2B,oDAAoD,EACtF,OAAO,yBAAyB,wCAAwC,SAAS,EACjF,OAAO,QAAQ,sCAAsC,EACrD,OAAO,iBAAiB,gBAAgB,EACxC,OAAO,YAAY,0BAA0B,EAC7C,OAAO,OAAO,WAAmB,YAAY;AAC5C,QAAM,QAAQ,WAAW,OAAO;AAClC,CAAC;AAGH,QACG,QAAQ,MAAM,EACd,YAAY,uCAAuC,EACnD,OAAO,iBAAiB,yBAAyB,EACjD,OAAO,kBAAkB,0BAA0B,EACnD,OAAO,eAAe,0BAA0B,EAChD,OAAO,OAAO,YAAY;AACzB,QAAM,QAAQ,OAAO;AACvB,CAAC;AAGH,QACG,QAAQ,KAAK,EACb,YAAY,sCAAsC,EAClD,OAAO,uBAAuB,qBAAqB,EACnD,OAAO,aAAa,iDAAiD,EACrE,OAAO,OAAO,YAAY;AACzB,QAAM,OAAO,OAAO;AACtB,CAAC;AAGH,QACG,QAAQ,cAAc,EACtB,YAAY,qCAAqC,EACjD,OAAO,wBAAwB,6BAA6B,KAAK,EACjE,OAAO,yBAAyB,iCAAiC,SAAS,EAC1E,OAAO,OAAO,YAAY;AACzB,QAAM,eAAe,OAAO;AAC9B,CAAC;AAGH,QACG,QAAQ,OAAO,EACf,YAAY,kCAAkC,EAC9C,OAAO,uBAAuB,qBAAqB,EACnD,OAAO,OAAO,YAAY;AACzB,QAAM,SAAS,OAAO;AACxB,CAAC;AAGH,QAAQ,MAAM;AAKd,eAAe,QACb,WACA,SAQe;AACf,QAAM,UAAUC,SAAQ,SAAS;AAEjC,MAAI,QAAQ,SAAS;AACnB,WAAO,WAAW,IAAI;AAAA,EACxB;AAEA,MAAI;AAEF,QAAI,EAAE,OAAO,IAAI,MAAM,WAAW,QAAQ,QAAQ,OAAO;AAGzD,QAAI,QAAQ,KAAK;AACf,eAAS,qBAAqB,QAAQ,QAAQ,GAAG;AAAA,IACnD;AAGA,QAAI,QAAQ,QAAQ;AAClB,aAAO,SAAS;AAAA,IAClB;AAGA,UAAM,UAAU,QAAQ,WAAW,aAAa,CAAC,QAAQ,KAAK,cAAc,qBAAqB,IAAI;AACrG,aAAS,MAAM;AAEf,UAAM,SAAS,MAAM,QAAQ,EAAE,QAAQ,SAAS,QAAQ,QAAQ,CAAC;AAEjE,aAAS,KAAK,OAAO,MAAM,eAAe,CAAC;AAG3C,YAAQ,QAAQ,QAAQ;AAAA,MACtB,KAAK;AACH,gBAAQ,IAAI,aAAa,MAAM,CAAC;AAChC;AAAA,MACF,KAAK;AACH,gBAAQ,IAAI,cAAc,MAAM,CAAC;AACjC;AAAA,MACF;AACE,YAAI,QAAQ,IAAI;AACd,sBAAY,MAAM;AAAA,QACpB,OAAO;AACL,0BAAgB,QAAQ,EAAE,SAAS,QAAQ,QAAQ,CAAC;AAAA,QACtD;AAAA,IACJ;AAGA,UAAM,YAAY,OAAO,SACrB,OAAO,MAAM,aAAa,KAAK,OAAO,MAAM,eAAe,IAC3D,OAAO,MAAM,aAAa;AAE9B,QAAI,QAAQ,MAAM,WAAW;AAC3B,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,SAAS,KAAK;AACZ,WAAO,MAAM,oBAAoB,eAAe,QAAQ,IAAI,UAAU,eAAe;AACrF,QAAI,QAAQ,WAAW,eAAe,OAAO;AAC3C,cAAQ,MAAM,IAAI,KAAK;AAAA,IACzB;AACA,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;AAKA,eAAe,QAAQ,SAIL;AAChB,QAAM,UAAU,QAAQ,IAAI;AAE5B,UAAQ,IAAI;AACZ,UAAQ,IAAIC,IAAG,KAAKA,IAAG,KAAK,YAAY,CAAC,IAAI,OAAO;AACpD,UAAQ,IAAI;AAGZ,MAAI,CAAC,QAAQ,aAAa;AACxB,UAAM,aAAaD,SAAQ,SAAS,sBAAsB;AAE1D,QAAK,MAAM,WAAW,UAAU,KAAM,CAAC,QAAQ,OAAO;AACpD,aAAO,KAAK,uDAAuD;AAAA,IACrE,OAAO;AACL,YAAM,UAAU,YAAY,uBAAuB,CAAC;AACpD,aAAO,QAAQ,WAAWC,IAAG,KAAK,sBAAsB,CAAC,EAAE;AAAA,IAC7D;AAAA,EACF;AAGA,MAAI,CAAC,QAAQ,YAAY;AACvB,UAAM,cAAcD,SAAQ,SAAS,cAAc;AAEnD,QAAK,MAAM,WAAW,WAAW,KAAM,CAAC,QAAQ,OAAO;AACrD,aAAO,KAAK,wDAAwD;AAAA,IACtE,OAAO;AAEL,YAAM,EAAE,OAAO,IAAI,MAAM,WAAW,QAAW,OAAO;AACtD,YAAM,SAAS,MAAM,QAAQ,EAAE,OAAO,CAAC;AAGvC,YAAM,UAAU;AAAA,QACd,GAAG,OAAO;AAAA,QACV,GAAG,OAAO,cACP,OAAO,CAAC,MAAM,EAAE,SAAS,WAAW,EACpC,OAAO,CAAC,MAAM,CAAC,OAAO,iBAAiB,KAAK,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,EACrE,IAAI,CAAC,OAAO;AAAA,UACX,MAAM,EAAE;AAAA,UACR,OAAO;AAAA,UACP,MAAM;AAAA,UACN,MAAM;AAAA,QACR,EAAE;AAAA,MACN;AAGA,YAAM,aAAa,MAAM,KAAK,IAAI,IAAI,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC;AAE/E,YAAM,kBAAkB,iBAAiB,YAAY;AAAA,QACnD,iBAAiB;AAAA,QACjB,eAAe;AAAA,QACf,aAAa;AAAA,MACf,CAAC;AAED,YAAM,UAAU,aAAa,eAAe;AAC5C,aAAO,QAAQ,WAAWC,IAAG,KAAK,cAAc,CAAC,SAAS,WAAW,MAAM,YAAY;AAAA,IACzF;AAAA,EACF;AAEA,UAAQ,IAAI;AACZ,UAAQ,IAAIA,IAAG,KAAK,aAAa,CAAC;AAClC,UAAQ,IAAIA,IAAG,KAAK,mDAAmD,CAAC;AACxE,UAAQ,IAAIA,IAAG,KAAK,4CAA4C,CAAC;AACjE,UAAQ,IAAI;AACd;AAKA,eAAe,OAAO,SAGJ;AAChB,QAAM,UAAU,QAAQ,IAAI;AAE5B,UAAQ,IAAI;AACZ,UAAQ,IAAIA,IAAG,KAAKA,IAAG,KAAK,YAAY,CAAC,IAAI,MAAM;AACnD,UAAQ,IAAI;AAEZ,MAAI;AAEF,UAAM,EAAE,OAAO,IAAI,MAAM,WAAW,QAAQ,QAAQ,OAAO;AAC3D,UAAM,SAAS,MAAM,QAAQ,EAAE,OAAO,CAAC;AAEvC,QAAI,OAAO,OAAO,WAAW,GAAG;AAC9B,aAAO,QAAQ,mBAAmB;AAClC;AAAA,IACF;AAGA,UAAM,EAAE,QAAQ,SAAS,MAAM,IAAI,MAAM,OAAO,mBAAmB;AAGnE,UAAM,gBAAgB,OAAO,OAAO,OAAO,CAAC,MAAM,EAAE,SAAS,SAAS;AACtE,UAAM,aAAa,OAAO,OAAO,OAAO,CAAC,MAAM,EAAE,SAAS,YAAY;AAEtE,QAAI,cAAc,SAAS,GAAG;AAC5B,cAAQ,IAAIA,IAAG,OAAO;AAAA,QAAW,cAAc,MAAM,sBAAsB,CAAC;AAE5E,iBAAW,SAAS,eAAe;AACjC,cAAM,SAAS,MAAM,OAAO;AAAA,UAC1B,SAAS,GAAG,MAAM,QAAQ,MAAM,MAAM,OAAO;AAAA,UAC7C,SAAS;AAAA,YACP,EAAE,MAAM,eAAe,OAAO,MAAM;AAAA,YACpC,EAAE,MAAM,sBAAsB,OAAO,SAAS;AAAA,YAC9C,EAAE,MAAM,QAAQ,OAAO,OAAO;AAAA,UAChC;AAAA,QACF,CAAC;AAED,YAAI,WAAW,OAAO;AACpB,gBAAM,QAAQ,MAAM,MAAM;AAAA,YACxB,SAAS,mBAAmB,MAAM,QAAQ;AAAA,YAC1C,SAAS;AAAA,UACX,CAAC;AAED,cAAI,CAAC,QAAQ,QAAQ;AAEnB,kBAAM,UAAUD,SAAQ,SAAS,MAAM;AACvC,kBAAM,UAAU;AAAA,EAAK,MAAM,QAAQ,IAAI,KAAK;AAAA;AAC5C,kBAAM,UAAU,SAAS,SAAS,EAAE,MAAM,IAAI,CAAC;AAC/C,mBAAO,QAAQ,SAAS,MAAM,QAAQ,UAAU;AAAA,UAClD,OAAO;AACL,mBAAO,KAAK,uBAAuB,MAAM,QAAQ,IAAI,KAAK,UAAU;AAAA,UACtE;AAAA,QACF,WAAW,WAAW,UAAU;AAC9B,iBAAO,KAAK,QAAQ,MAAM,QAAQ,4BAA4B;AAAA,QAChE;AAAA,MACF;AAAA,IACF;AAEA,QAAI,WAAW,SAAS,GAAG;AACzB,cAAQ,IAAIC,IAAG,OAAO;AAAA,QAAW,WAAW,MAAM,gBAAgB,CAAC;AAEnE,YAAM,aAAa,MAAM,QAAQ;AAAA,QAC/B,SAAS;AAAA,QACT,SAAS;AAAA,MACX,CAAC;AAED,UAAI,cAAc,CAAC,QAAQ,QAAQ;AACjC,cAAM,cAAcD,SAAQ,SAAS,cAAc;AACnD,cAAM,kBAAkB,iBAAiB,OAAO,kBAAkB;AAAA,UAChE,iBAAiB;AAAA,UACjB,eAAe;AAAA,UACf,aAAa;AAAA,QACf,CAAC;AAED,cAAM,UAAU,aAAa,eAAe;AAC5C,eAAO,QAAQ,sBAAsB;AAAA,MACvC;AAAA,IACF;AAGA,UAAM,kBAAkB,2BAA2B,OAAO,MAAM;AAChE,QAAI,gBAAgB,SAAS,GAAG;AAC9B,cAAQ,IAAI;AACZ,cAAQ,IAAIC,IAAG,KAAK,2BAA2B,CAAC;AAChD,iBAAW,OAAO,iBAAiB;AACjC,gBAAQ,IAAIA,IAAG,KAAK,YAAO,GAAG,EAAE,CAAC;AAAA,MACnC;AAAA,IACF;AAEA,YAAQ,IAAI;AAAA,EACd,SAAS,KAAK;AACZ,QAAK,IAAc,SAAS,mBAAmB;AAE7C,cAAQ,IAAI;AACZ;AAAA,IACF;AACA,UAAM;AAAA,EACR;AACF;AAKA,eAAe,eAAe,SAGZ;AAChB,QAAM,UAAU,QAAQ,IAAI;AAC5B,QAAM,QAAQ,SAAS,QAAQ,OAAO,EAAE;AAExC,UAAQ,IAAI;AACZ,UAAQ,IAAIA,IAAG,KAAKA,IAAG,KAAK,YAAY,CAAC,IAAI,eAAe;AAC5D,UAAQ,IAAI;AAEZ,QAAM,UAAU,cAAc,iBAAiB,KAAK,aAAa;AACjE,UAAQ,MAAM;AAEd,QAAM,EAAE,SAAS,MAAM,IAAI,MAAM,eAAe;AAAA,IAC9C;AAAA,IACA;AAAA,EACF,CAAC;AAED,UAAQ,KAAK,CAAC,KAAK;AAEnB,MAAI,OAAO;AACT,WAAO,MAAM,KAAK;AAClB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,MAAI,QAAQ,WAAW,GAAG;AACxB,WAAO,QAAQ,wCAAwC;AACvD;AAAA,EACF;AAEA,MAAI,QAAQ,WAAW,QAAQ;AAC7B,YAAQ,IAAI,KAAK,UAAU,EAAE,QAAQ,GAAG,MAAM,CAAC,CAAC;AAChD;AAAA,EACF;AAEA,UAAQ,IAAIA,IAAG,IAAI;AAAA,eAAa,QAAQ,MAAM;AAAA,CAAwC,CAAC;AAEvF,aAAW,UAAU,SAAS;AAC5B,YAAQ,IAAIA,IAAG,KAAK,KAAK,OAAO,QAAQ,EAAE,CAAC;AAC3C,YAAQ,IAAIA,IAAG,KAAK,eAAe,OAAO,OAAO,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC;AAC/D,YAAQ,IAAIA,IAAG,KAAK,aAAa,OAAO,IAAI,IAAI,OAAO,IAAI,EAAE,CAAC;AAC9D,YAAQ,IAAIA,IAAG,KAAK,eAAe,OAAO,MAAM,EAAE,CAAC;AACnD,YAAQ,IAAIA,IAAG,KAAK,aAAa,OAAO,IAAI,EAAE,CAAC;AAC/C,YAAQ,IAAIA,IAAG,KAAK,cAAc,OAAO,aAAa,EAAE,CAAC;AACzD,YAAQ,IAAI;AAAA,EACd;AAEA,UAAQ,IAAIA,IAAG,OAAO,qHAAqH,CAAC;AAC5I,UAAQ,IAAI;AAEZ,UAAQ,KAAK,CAAC;AAChB;AAKA,eAAe,SAAS,SAA6C;AACnE,QAAM,UAAU,QAAQ,IAAI;AAE5B,UAAQ,IAAI;AACZ,UAAQ,IAAIA,IAAG,KAAKA,IAAG,KAAK,YAAY,CAAC,IAAI,QAAQ;AACrD,UAAQ,IAAIA,IAAG,KAAK,+CAA+C,CAAC;AACpE,UAAQ,IAAI;AAEZ,QAAM,EAAE,OAAO,IAAI,MAAM,WAAW,QAAQ,QAAQ,OAAO;AAE3D,MAAI,iBAAwC;AAC5C,MAAI,gBAAuC;AAE3C,QAAM,cAAc,YAAY;AAC9B,QAAI;AACF,YAAM,SAAS,MAAM,QAAQ,EAAE,OAAO,CAAC;AAGvC,UACE,CAAC,kBACD,OAAO,OAAO,WAAW,eAAe,OAAO,UAC/C,OAAO,MAAM,eAAe,eAAe,MAAM,YACjD;AACA,gBAAQ,MAAM;AACd,gBAAQ,IAAIA,IAAG,KAAKA,IAAG,KAAK,YAAY,CAAC,IAAI,QAAQ;AACrD,gBAAQ,IAAIA,IAAG,KAAK,kBAAiB,oBAAI,KAAK,GAAE,mBAAmB,CAAC,EAAE,CAAC;AACvE,gBAAQ,IAAI;AACZ,wBAAgB,QAAQ,EAAE,SAAS,MAAM,CAAC;AAC1C,yBAAiB;AAAA,MACnB;AAAA,IACF,SAAS,KAAK;AACZ,aAAO,MAAM,mBAAmB,eAAe,QAAQ,IAAI,UAAU,eAAe;AAAA,IACtF;AAAA,EACF;AAGA,QAAM,YAAY;AAGlB,QAAM,EAAE,MAAM,IAAI,MAAM,OAAO,IAAS;AACxC,QAAM,cAAc,oBAAI,IAAY;AAGpC,aAAW,WAAW,OAAO,UAAU;AACrC,UAAM,UAAUD,SAAQ,SAAS,OAAO;AACxC,QAAI;AACF,YAAM,SAAS,MAAM;AACnB,YAAI,cAAe,cAAa,aAAa;AAC7C,wBAAgB,WAAW,aAAa,GAAG;AAAA,MAC7C,CAAC;AACD,kBAAY,IAAI,OAAO;AAAA,IACzB,QAAQ;AAAA,IAER;AAAA,EACF;AAGA,QAAM,SAASA,SAAQ,SAAS,KAAK;AACrC,MAAI;AACF,UAAM,QAAQ,EAAE,WAAW,KAAK,GAAG,CAAC,QAAQ,aAAa;AACvD,UAAI,YAAY,qBAAqB,KAAK,QAAQ,GAAG;AACnD,YAAI,cAAe,cAAa,aAAa;AAC7C,wBAAgB,WAAW,aAAa,GAAG;AAAA,MAC7C;AAAA,IACF,CAAC;AACD,gBAAY,IAAI,MAAM;AAAA,EACxB,QAAQ;AAAA,EAER;AAGA,UAAQ,GAAG,UAAU,MAAM;AACzB,YAAQ,IAAI;AACZ,YAAQ,IAAIC,IAAG,KAAK,mBAAmB,CAAC;AACxC,YAAQ,KAAK,CAAC;AAAA,EAChB,CAAC;AAGD,QAAM,IAAI,QAAQ,MAAM;AAAA,EAAC,CAAC;AAC5B;","names":["path","resolve","dirname","init_config","init_config","pc","resolve","readFile","resolve","readFile","relative","resolve","readFile","relative","resolve","isPlaceholderValue","pc","SECRET_VALUE_PATTERNS","redactValue","resolve","pc"]}