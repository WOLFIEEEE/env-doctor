/**
 * @fileoverview Template formatter for generating .env.example files
 */

import type { EnrichedVariable, SyncConfig, TemplateSection } from './types.js';
import { DEFAULT_SYNC_CONFIG, DEFAULT_CATEGORIES } from './types.js';

/**
 * Format a template from enriched variables
 */
export function formatTemplate(
  variables: EnrichedVariable[],
  config: Partial<SyncConfig> = {}
): string {
  const mergedConfig = mergeConfig(config);
  const lines: string[] = [];

  // Add header comment
  if (mergedConfig.format.headerComment) {
    lines.push(...generateHeader());
    lines.push('');
  }

  // Group variables
  const groups = groupVariables(variables, mergedConfig);

  // Format each group
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    
    if (mergedConfig.format.sectionDividers && group.name) {
      lines.push(...formatSectionHeader(group.name, group.description));
    }

    // Format variables in group
    for (const variable of group.variables) {
      lines.push(...formatVariable(variable, mergedConfig));
    }

    // Add blank line between groups
    if (mergedConfig.format.blankLinesBetweenGroups && i < groups.length - 1) {
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Merge user config with defaults
 */
function mergeConfig(config: Partial<SyncConfig>): Required<SyncConfig> {
  return {
    sources: { ...DEFAULT_SYNC_CONFIG.sources, ...config.sources },
    groupBy: config.groupBy ?? DEFAULT_SYNC_CONFIG.groupBy,
    categories: { ...DEFAULT_SYNC_CONFIG.categories, ...config.categories },
    include: { ...DEFAULT_SYNC_CONFIG.include, ...config.include },
    values: { ...DEFAULT_SYNC_CONFIG.values, ...config.values },
    format: { ...DEFAULT_SYNC_CONFIG.format, ...config.format },
    preserve: { ...DEFAULT_SYNC_CONFIG.preserve, ...config.preserve },
  };
}

/**
 * Generate header comment
 */
function generateHeader(): string[] {
  const date = new Date().toISOString().split('T')[0];
  return [
    '# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '# Environment Configuration Template',
    `# Generated by env-doctor on ${date}`,
    '#',
    '# Copy this file to .env and fill in the values.',
    '# Run `npx env-doctor` to validate your configuration.',
    '# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
  ];
}

/**
 * Format a section header
 */
function formatSectionHeader(name: string, description?: string): string[] {
  const lines = [
    '',
    '# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
    `# ${name}`,
  ];
  
  if (description) {
    lines.push(`# ${description}`);
  }
  
  lines.push('# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  lines.push('');
  
  return lines;
}

/**
 * Format a single variable with its metadata
 */
function formatVariable(
  variable: EnrichedVariable,
  config: Required<SyncConfig>
): string[] {
  const lines: string[] = [];
  const comments: string[] = [];

  // Add description
  if (config.include.descriptions && variable.description) {
    comments.push(`# ${variable.description}`);
  }

  // Add type hint
  if (config.include.types && variable.type) {
    comments.push(`# Type: ${variable.type}`);
  }

  // Add required indicator
  if (config.include.required && variable.required) {
    comments.push('# Required: Yes');
  }

  // Add example
  if (config.include.examples && variable.example) {
    comments.push(`# Example: ${variable.example}`);
  }

  // Add default value hint
  if (config.include.defaults && variable.inferredType) {
    const defaultVal = getDefaultHint(variable);
    if (defaultVal) {
      comments.push(`# Default: ${defaultVal}`);
    }
  }

  // Add secret warning
  if (config.include.secretWarnings && variable.isSecret) {
    comments.push('# âš ï¸  SECRET - Do not commit actual value');
  }

  // Add documentation link
  if (config.include.docsLinks && variable.docsUrl) {
    comments.push(`# Docs: ${variable.docsUrl}`);
  }

  // Add hints
  if (variable.hints && variable.hints.length > 0) {
    for (const hint of variable.hints) {
      comments.push(`# ğŸ’¡ ${hint}`);
    }
  }

  // Add all comments
  lines.push(...comments);

  // Format the variable line
  const value = formatValue(variable, config);
  lines.push(`${variable.name}=${value}`);

  return lines;
}

/**
 * Format the value for a variable
 */
function formatValue(
  variable: EnrichedVariable,
  config: Required<SyncConfig>
): string {
  // Handle secrets
  if (variable.isSecret) {
    switch (config.values.secrets) {
      case 'placeholder':
        return '<your-secret-here>';
      case 'redacted':
        return '***REDACTED***';
      case 'empty':
      default:
        return '';
    }
  }

  // Handle non-secrets
  switch (config.values.nonSecrets) {
    case 'example':
      return variable.example || variable.value || '';
    case 'default':
      return getDefaultValue(variable);
    case 'empty':
    default:
      return '';
  }
}

/**
 * Get default value for a variable
 */
function getDefaultValue(variable: EnrichedVariable): string {
  // Use explicit value if available
  if (variable.value && !variable.isSecret) {
    return variable.value;
  }

  // Infer from type
  switch (variable.type || variable.inferredType) {
    case 'number':
      return variable.name === 'PORT' ? '3000' : '';
    case 'boolean':
      return 'false';
    case 'url':
      return '';
    default:
      if (variable.name === 'NODE_ENV') return 'development';
      return '';
  }
}

/**
 * Get a default hint for documentation
 */
function getDefaultHint(variable: EnrichedVariable): string | null {
  if (variable.value && !variable.isSecret) {
    return variable.value;
  }
  
  if (variable.name === 'PORT') return '3000';
  if (variable.name === 'NODE_ENV') return 'development';
  if (variable.type === 'boolean') return 'false';
  
  return null;
}

/**
 * Group variables by category, prefix, or file
 */
interface VariableGroup {
  name: string;
  description?: string;
  priority: number;
  variables: EnrichedVariable[];
}

function groupVariables(
  variables: EnrichedVariable[],
  config: Required<SyncConfig>
): VariableGroup[] {
  switch (config.groupBy) {
    case 'category':
      return groupByCategory(variables, config);
    case 'prefix':
      return groupByPrefix(variables);
    case 'file':
      return groupByFile(variables);
    case 'none':
    default:
      return [{
        name: '',
        priority: 0,
        variables: variables.sort((a, b) => a.name.localeCompare(b.name)),
      }];
  }
}

/**
 * Group variables by category using pattern matching
 */
function groupByCategory(
  variables: EnrichedVariable[],
  config: Required<SyncConfig>
): VariableGroup[] {
  const groups = new Map<string, VariableGroup>();
  const uncategorized: EnrichedVariable[] = [];

  // Build category list from defaults and custom
  const categories = [...DEFAULT_CATEGORIES];
  
  // Add custom categories from config
  for (const [name, patterns] of Object.entries(config.categories)) {
    const existing = categories.find(c => c.name === name);
    if (existing) {
      existing.patterns.push(...patterns);
    } else {
      categories.push({
        name,
        patterns,
        priority: categories.length + 10,
      });
    }
  }

  // Categorize each variable
  for (const variable of variables) {
    let matched = false;

    for (const category of categories) {
      if (matchesCategory(variable.name, category.patterns)) {
        if (!groups.has(category.name)) {
          groups.set(category.name, {
            name: category.name,
            description: category.description,
            priority: category.priority ?? 99,
            variables: [],
          });
        }
        groups.get(category.name)!.variables.push(variable);
        variable.category = category.name;
        matched = true;
        break;
      }
    }

    if (!matched) {
      uncategorized.push(variable);
    }
  }

  // Sort variables within each group
  for (const group of groups.values()) {
    group.variables.sort((a, b) => a.name.localeCompare(b.name));
  }

  // Sort groups by priority
  const sortedGroups = Array.from(groups.values())
    .sort((a, b) => a.priority - b.priority);

  // Add uncategorized at the end
  if (uncategorized.length > 0) {
    sortedGroups.push({
      name: 'Other',
      description: 'Miscellaneous variables',
      priority: 100,
      variables: uncategorized.sort((a, b) => a.name.localeCompare(b.name)),
    });
  }

  return sortedGroups;
}

/**
 * Check if a variable name matches any of the category patterns
 */
function matchesCategory(name: string, patterns: string[]): boolean {
  for (const pattern of patterns) {
    if (matchesPattern(name, pattern)) {
      return true;
    }
  }
  return false;
}

/**
 * Simple glob-like pattern matching
 */
function matchesPattern(name: string, pattern: string): boolean {
  // Handle exact match
  if (!pattern.includes('*')) {
    return name === pattern;
  }

  // Handle prefix match (e.g., "DATABASE_*")
  if (pattern.endsWith('*') && !pattern.startsWith('*')) {
    const prefix = pattern.slice(0, -1);
    return name.startsWith(prefix);
  }

  // Handle suffix match (e.g., "*_URL")
  if (pattern.startsWith('*') && !pattern.endsWith('*')) {
    const suffix = pattern.slice(1);
    return name.endsWith(suffix);
  }

  // Handle contains match (e.g., "*SECRET*")
  if (pattern.startsWith('*') && pattern.endsWith('*')) {
    const middle = pattern.slice(1, -1);
    return name.includes(middle);
  }

  return false;
}

/**
 * Group variables by their prefix
 */
function groupByPrefix(variables: EnrichedVariable[]): VariableGroup[] {
  const groups = new Map<string, VariableGroup>();

  for (const variable of variables) {
    const prefix = getPrefix(variable.name);
    const groupName = prefix ? formatPrefixName(prefix) : 'Other';

    if (!groups.has(groupName)) {
      groups.set(groupName, {
        name: groupName,
        priority: groupName === 'Other' ? 100 : 0,
        variables: [],
      });
    }
    groups.get(groupName)!.variables.push(variable);
  }

  // Sort variables and groups
  for (const group of groups.values()) {
    group.variables.sort((a, b) => a.name.localeCompare(b.name));
  }

  return Array.from(groups.values())
    .sort((a, b) => {
      if (a.priority !== b.priority) return a.priority - b.priority;
      return a.name.localeCompare(b.name);
    });
}

/**
 * Group variables by their source file
 */
function groupByFile(variables: EnrichedVariable[]): VariableGroup[] {
  const groups = new Map<string, VariableGroup>();

  for (const variable of variables) {
    const file = variable.file || 'unknown';

    if (!groups.has(file)) {
      groups.set(file, {
        name: file,
        priority: 0,
        variables: [],
      });
    }
    groups.get(file)!.variables.push(variable);
  }

  // Sort variables within groups
  for (const group of groups.values()) {
    group.variables.sort((a, b) => a.name.localeCompare(b.name));
  }

  return Array.from(groups.values())
    .sort((a, b) => a.name.localeCompare(b.name));
}

/**
 * Get the prefix of a variable name
 */
function getPrefix(name: string): string {
  const parts = name.split('_');
  if (parts.length > 1) {
    // Check for common multi-part prefixes
    if (parts[0] === 'NEXT' && parts[1] === 'PUBLIC') return 'NEXT_PUBLIC_';
    if (parts[0] === 'REACT' && parts[1] === 'APP') return 'REACT_APP_';
    return parts[0] + '_';
  }
  return '';
}

/**
 * Format a prefix name for display
 */
function formatPrefixName(prefix: string): string {
  return prefix
    .replace(/_$/, '')
    .replace(/_/g, ' ')
    .toLowerCase()
    .replace(/\b\w/g, (c) => c.toUpperCase());
}

/**
 * Wrap text to a maximum line length
 */
export function wrapText(text: string, maxLength: number, prefix: string = '# '): string[] {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = prefix;

  for (const word of words) {
    if (currentLine.length + word.length + 1 > maxLength) {
      lines.push(currentLine.trimEnd());
      currentLine = prefix + word;
    } else {
      currentLine += (currentLine === prefix ? '' : ' ') + word;
    }
  }

  if (currentLine !== prefix) {
    lines.push(currentLine.trimEnd());
  }

  return lines;
}

