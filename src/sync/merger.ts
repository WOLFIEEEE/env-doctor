/**
 * @fileoverview Smart merger for .env.example files
 */

import { readFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import type { EnrichedVariable, SyncConfig, MergeResult, ParsedTemplateVariable, TemplateSection } from './types.js';
import { formatTemplate } from './formatter.js';
import { fileExists } from '../utils/fs.js';

/**
 * Options for merge operation
 */
export interface MergeOptions {
  /** Path to existing template file */
  templatePath: string;
  /** New variables to merge */
  newVariables: EnrichedVariable[];
  /** Sync configuration */
  syncConfig?: Partial<SyncConfig>;
  /** Root directory */
  rootDir?: string;
}

/**
 * Merge new variables with existing template
 */
export async function mergeTemplate(options: MergeOptions): Promise<MergeResult> {
  const {
    templatePath,
    newVariables,
    syncConfig = {},
    rootDir = process.cwd(),
  } = options;

  const fullPath = resolve(rootDir, templatePath);
  const warnings: string[] = [];

  // Check if template exists
  if (!await fileExists(fullPath)) {
    // No existing template, just generate new one
    const content = formatTemplate(newVariables, syncConfig);
    return {
      content,
      added: newVariables.map(v => v.name),
      removed: [],
      updated: [],
      preserved: [],
      warnings: [],
    };
  }

  // Parse existing template
  const existingContent = await readFile(fullPath, 'utf-8');
  const parsed = parseTemplate(existingContent);

  // Build maps for comparison
  const existingMap = new Map<string, ParsedTemplateVariable>();
  const existingCustomComments = new Map<string, string[]>();

  for (const section of parsed.sections) {
    for (const variable of section.variables) {
      existingMap.set(variable.name, variable);
      if (variable.comments.length > 0) {
        existingCustomComments.set(variable.name, variable.comments);
      }
    }
  }

  const newMap = new Map(newVariables.map(v => [v.name, v]));

  // Track changes
  const added: string[] = [];
  const removed: string[] = [];
  const updated: string[] = [];
  const preserved: string[] = [];

  // Find new variables
  for (const [name] of newMap) {
    if (!existingMap.has(name)) {
      added.push(name);
    }
  }

  // Find removed variables
  for (const [name, existing] of existingMap) {
    if (!newMap.has(name)) {
      if (syncConfig.preserve?.customVariables && existing.isCustom) {
        preserved.push(name);
      } else {
        removed.push(name);
      }
    }
  }

  // Find updated variables (where we might update metadata)
  for (const [name, newVar] of newMap) {
    if (existingMap.has(name)) {
      // Check if any metadata changed
      const existing = existingMap.get(name)!;
      if (hasMetadataChanges(existing, newVar)) {
        updated.push(name);
      }
    }
  }

  // Build merged variables
  const mergedVariables: EnrichedVariable[] = [];

  // Add new variables
  for (const variable of newVariables) {
    const existing = existingMap.get(variable.name);
    if (existing && syncConfig.preserve?.customComments) {
      // Preserve custom comments from existing template
      const customComments = existingCustomComments.get(variable.name);
      if (customComments && customComments.length > 0) {
        // Filter out auto-generated comments and keep custom ones
        const keptComments = customComments.filter(c => !isAutoGeneratedComment(c));
        if (keptComments.length > 0) {
          variable.hints = [...(variable.hints || []), ...keptComments.map(c => c.replace(/^#\s*/, ''))];
        }
      }
    }
    mergedVariables.push(variable);
  }

  // Add preserved custom variables
  if (syncConfig.preserve?.customVariables) {
    for (const name of preserved) {
      const existing = existingMap.get(name)!;
      mergedVariables.push({
        name: existing.name,
        value: existing.value,
        line: existing.line,
        file: '',
        hints: existing.comments
          .filter(c => !isAutoGeneratedComment(c))
          .map(c => c.replace(/^#\s*/, '')),
      });
    }
  }

  // Generate content
  const content = formatTemplate(mergedVariables, syncConfig);

  return {
    content,
    added,
    removed,
    updated,
    preserved,
    warnings,
  };
}

/**
 * Parse an existing template file
 */
export function parseTemplate(content: string): { sections: TemplateSection[] } {
  const lines = content.split('\n');
  const sections: TemplateSection[] = [];
  let currentSection: TemplateSection = {
    name: '',
    headerComments: [],
    variables: [],
  };
  let pendingComments: string[] = [];
  let isInHeader = true;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();

    // Skip empty lines
    if (!trimmed) {
      if (pendingComments.length > 0 && !isInHeader) {
        // Empty line after comments might indicate a section break
        pendingComments = [];
      }
      continue;
    }

    // Handle comments
    if (trimmed.startsWith('#')) {
      // Check if this is a section header
      if (isSectionHeader(trimmed, lines[i + 1])) {
        // Save current section if it has variables
        if (currentSection.variables.length > 0) {
          sections.push(currentSection);
        }

        // Start new section
        currentSection = {
          name: extractSectionName(trimmed),
          headerComments: [trimmed],
          variables: [],
        };
        pendingComments = [];
        isInHeader = false;
      } else {
        pendingComments.push(trimmed);
        if (isFileHeader(trimmed)) {
          isInHeader = true;
        }
      }
      continue;
    }

    isInHeader = false;

    // Handle variable line
    const match = trimmed.match(/^([A-Z][A-Z0-9_]*)=(.*)$/);
    if (match) {
      const [, name, value] = match;
      currentSection.variables.push({
        name,
        value,
        comments: [...pendingComments],
        line: i + 1,
        isCustom: false,
      });
      pendingComments = [];
    }
  }

  // Save last section
  if (currentSection.variables.length > 0) {
    sections.push(currentSection);
  }

  return { sections };
}

/**
 * Check if a comment line is a section header
 */
function isSectionHeader(line: string, nextLine?: string): boolean {
  // Section headers are usually lines of dashes or equals
  if (/^#\s*[-â”€â•]{10,}/.test(line)) {
    return true;
  }
  
  // Or followed by a line of dashes
  if (nextLine && /^#\s*[-â”€â•]{10,}/.test(nextLine)) {
    return true;
  }

  return false;
}

/**
 * Check if this is part of the file header
 */
function isFileHeader(line: string): boolean {
  return /^#\s*(Environment|Generated|Copy this|Run `)/i.test(line) ||
         /^#\s*[â•â”€]{20,}/.test(line);
}

/**
 * Extract section name from header line
 */
function extractSectionName(line: string): string {
  // Remove # and dashes, trim
  return line
    .replace(/^#\s*/, '')
    .replace(/[-â”€â•]+/g, '')
    .trim();
}

/**
 * Check if a comment is auto-generated
 */
function isAutoGeneratedComment(comment: string): boolean {
  const autoPatterns = [
    /^#\s*Type:/,
    /^#\s*Required:/,
    /^#\s*Default:/,
    /^#\s*Example:/,
    /^#\s*Docs:/,
    /^#\s*âš ï¸/,
    /^#\s*ðŸ’¡/,
    /^#\s*[-â”€â•]{10,}/,
  ];

  return autoPatterns.some(p => p.test(comment));
}

/**
 * Check if metadata has changed
 */
function hasMetadataChanges(
  existing: ParsedTemplateVariable,
  newVar: EnrichedVariable
): boolean {
  // Check if type, required, description changed
  // For now, we'll consider any difference as a potential update
  return existing.value !== (newVar.value || '');
}

/**
 * Generate a diff preview between two templates
 */
export function generateDiff(
  oldContent: string,
  newContent: string
): string {
  const oldLines = oldContent.split('\n');
  const newLines = newContent.split('\n');
  const diff: string[] = [];

  diff.push('--- .env.example (current)');
  diff.push('+++ .env.example (proposed)');
  diff.push('');

  // Simple line-by-line diff
  const maxLen = Math.max(oldLines.length, newLines.length);
  let contextStart = -1;
  let contextEnd = -1;
  let changes: string[] = [];

  for (let i = 0; i < maxLen; i++) {
    const oldLine = oldLines[i] ?? '';
    const newLine = newLines[i] ?? '';

    if (oldLine !== newLine) {
      if (contextStart === -1) {
        contextStart = Math.max(0, i - 3);
      }
      contextEnd = Math.min(maxLen - 1, i + 3);

      if (oldLine && !newLine) {
        changes.push(`-${oldLine}`);
      } else if (!oldLine && newLine) {
        changes.push(`+${newLine}`);
      } else {
        changes.push(`-${oldLine}`);
        changes.push(`+${newLine}`);
      }
    } else if (contextStart !== -1 && i <= contextEnd) {
      changes.push(` ${oldLine}`);
    }

    // Output context block when we're past the context end
    if (i > contextEnd && contextStart !== -1 && changes.length > 0) {
      diff.push(`@@ -${contextStart + 1},${contextEnd - contextStart + 1} +${contextStart + 1},${contextEnd - contextStart + 1} @@`);
      diff.push(...changes);
      diff.push('');
      changes = [];
      contextStart = -1;
      contextEnd = -1;
    }
  }

  // Output remaining changes
  if (changes.length > 0) {
    diff.push(`@@ -${contextStart + 1},${contextEnd - contextStart + 1} +${contextStart + 1},${contextEnd - contextStart + 1} @@`);
    diff.push(...changes);
  }

  return diff.join('\n');
}

/**
 * Apply a merge result to the filesystem
 */
export async function applyMerge(
  templatePath: string,
  result: MergeResult,
  rootDir: string = process.cwd()
): Promise<void> {
  const { writeFile } = await import('node:fs/promises');
  const fullPath = resolve(rootDir, templatePath);
  await writeFile(fullPath, result.content, 'utf-8');
}

